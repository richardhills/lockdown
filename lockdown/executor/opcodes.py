# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from abc import abstractmethod
import ast

from lockdown.executor.ast_utils import compile_expression, compile_statement, \
    unwrap_modules, wrap_as_statement
from lockdown.executor.exceptions import PreparationException
from lockdown.executor.flow_control import BreakTypesFactory, BreakException
from lockdown.executor.function_type import OpenFunctionType, ClosedFunctionType
from lockdown.executor.operands import OpcodeOperandMixin, Operand, BoundOperand
from lockdown.executor.raw_code_factories import dereference, assignment_op, \
    literal_op
from lockdown.executor.type_factories import enrich_type
from lockdown.executor.utils import evaluate, TypeErrorFactory, \
    get_expression_break_types, flatten_out_types, MicroOpBinder, \
    each_reference, get_best_micro_op, get_operand_type, get_context_type, \
    ContextSearcher
from lockdown.type_system.composites import CompositeType, scoped_bind, \
    does_value_fit_through_type, is_type_bindable_to_value, Composite
from lockdown.type_system.core_types import AnyType, merge_types, Const, \
    UnitType, NoValueType, PermittedValuesDoesNotExist, unwrap_types, IntegerType, \
    BooleanType, remove_type, BottomType, ValueType
from lockdown.type_system.exceptions import FatalError, InvalidDereferenceType, \
    InvalidDereferenceKey, InvalidAssignmentType, InvalidAssignmentKey
from lockdown.type_system.managers import get_type_of_value, get_manager
from lockdown.type_system.reasoner import DUMMY_REASONER, Reasoner
from lockdown.type_system.universal_type import UniversalObjectType, \
    DEFAULT_READONLY_COMPOSITE_TYPE, PythonList, UniversalListType, PythonObject, \
    GetterMicroOpType, SetterMicroOpType, GetterWildcardMicroOpType, \
    SetterWildcardMicroOpType, InsertStartMicroOpType, InsertEndMicroOpType, DeletterWildcardMicroOpType, \
    IterMicroOpType, RemoverWildcardMicroOpType, InserterWildcardMicroOpType, \
    UniversalTupleType, Universal, SPARSE_ELEMENT, RICH_TYPE, RICH_READONLY_TYPE, \
    PythonDict
from lockdown.utils.utils import MISSING, NO_VALUE, InternalMarker, get_environment, \
    spread_dict


class Opcode(object):
    """
    Base class for all Opcodes used in Lockdown. 
    """
    def __init__(self, data, visitor):
        self.data = data
        self.break_types = None

    @abstractmethod
    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        """
        Returns all the break modes and types at verification time. Later, when
        .jump is called, flow can only leave the opcode via the break modes returned
        by this function.

        Returns a dictionary of the different break modes and the associated types for
        each one, that can be generated by this opcode, or by other opcodes invoked by
        this one.
        
        Example, can return:
        {
            "value": [{
                "out": IntegerType()
            }],
            "exception": [{
                "out": TypeError()
            }]
        }
        """
        raise NotImplementedError()

    @abstractmethod
    def jump(self, context, frame_manager, hooks, immediate_context=None):
        """
        Entry point for Opcode at run time. We jump into the opcode, and it returns
        by either raising a BreakException, or by returning a tuple of

        (mode, value, opcode, restart_type)

        See Frame.unwind() for details on how this can return.
        """
        raise NotImplementedError()

    def get_start_and_end(self):
        return (getattr(self.data, "start", None), getattr(self.data, "end", None))

    def return_value_jump(self, context, frame_manager, hooks, immediate_context=None):
        return evaluate(self, context, frame_manager, hooks, immediate_context)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression(
            "{return_value_jump}({context_name}, _frame_manager, _hooks)",
            context_name, dependency_builder, return_value_jump=self.return_value_jump
        )


class Nop(Opcode):
    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add(self, "value", NoValueType())
        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(self, NO_VALUE)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression("NoValue", context_name, dependency_builder)


class LiteralOp(Opcode):
    def __init__(self, data, visitor):
        super(LiteralOp, self).__init__(data, visitor)
        self.value = data._get("value")

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add(self, "value", get_type_of_value(self.value))
        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(self, self.value)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if isinstance(self.value, bool):
            return ast.NameConstant(self.value)
        if isinstance(self.value, int):
            return ast.Num(n=self.value)
        if isinstance(self.value, str):
            return ast.Str(s=self.value)
        raise FatalError()

    def __str__(self):
        return "LiteralOp<{}>".format(self.value)


class TemplateOp(OpcodeOperandMixin, Opcode):
    NO_VALUE_ASSIGNMENT = TypeErrorFactory("TemplateOp: no_value_assignment")

    def __init__(self, data, visitor):
        super(TemplateOp, self).__init__(data, visitor)
        if not isinstance(data._get("opcodes", MISSING), PythonList):
            raise FatalError()

        for e in data._get("opcodes"):
            if not isinstance(e, tuple) and len(e) != 2:
                raise FatalError()

        self.operands = [(
                BoundOperand(
                    "{}-key".format(index),
                    self,
                    enrich_opcode(key, visitor),
                    ValueType(),
                    self.NO_VALUE_ASSIGNMENT
                ),
                BoundOperand(
                    "{}-value".format(index),
                    self,
                    enrich_opcode(opcode, visitor),
                    ValueType(),
                    self.NO_VALUE_ASSIGNMENT
                )
            )
            for index, (key, opcode) in enumerate([ c._to_list() for c in data._get("opcodes")._to_list()])
        ]

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        can_run = True
        for key_operand, value_operand in self.operands:
            can_run = can_run and key_operand.prepare(break_types, context, frame_manager, hooks, immediate_context)
            can_run = can_run and value_operand.prepare(break_types, context, frame_manager, hooks, immediate_context)

        if can_run:
            micro_ops = {}
            all_key_types = []
            all_value_types = []

            for key_operand, value_operand in self.operands:
                try:
                    allowed_keys = key_operand.value_type.get_all_permitted_values()
                    if len(allowed_keys) == 1:
                        key = allowed_keys[0]
                except PermittedValuesDoesNotExist:
                    pass

                all_key_types.extend(unwrap_types(key_operand.value_type))
                all_value_types.extend(unwrap_types(value_operand.value_type))
                micro_ops[("get", key)] = GetterMicroOpType(key, value_operand.value_type)
                micro_ops[("set", key)] = SetterMicroOpType(key, AnyType())

            combined_key_types = merge_types([ BottomType() ] + all_key_types, "exact")
            combined_value_types = merge_types([ BottomType() ] + all_value_types, "exact")
            have_default_factory = False

            micro_ops[("get-wildcard",)] = GetterWildcardMicroOpType(AnyType(), combined_value_types, True)
            micro_ops[("iter",)] = IterMicroOpType(combined_key_types, combined_value_types)
            micro_ops[("set-wildcard",)] = SetterWildcardMicroOpType(AnyType(), AnyType(), False, False)
            micro_ops[("delete-wildcard",)] = DeletterWildcardMicroOpType(AnyType(), not have_default_factory)
            micro_ops[("remove-wildcard",)] = RemoverWildcardMicroOpType(not have_default_factory, False)
            micro_ops[("insert-wildcard",)] = InserterWildcardMicroOpType(AnyType(), False, False)

            micro_ops[("insert-start",)] = InsertStartMicroOpType(AnyType(), False)
            micro_ops[("insert-end",)] = InsertEndMicroOpType(AnyType(), False)

            value_type = CompositeType(micro_ops, name="TemplateOp")

            break_types.add(self, "value", value_type)

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            result = {}

            initial_length = 0

            for key_operand, value_operand in self.operands:
                key = key_operand.get(context, frame, hooks)
                new_value = value_operand.get(context, frame, hooks)

                if new_value is NO_VALUE:
                    return frame.exception(self, self.NO_VALUE_ASSIGNMENT())

                if isinstance(key, int):
                    required_length_for_key = key + 1
                    initial_length = max([ required_length_for_key, initial_length ])

                result[key] = new_value

            return frame.value(
                self, 
                Universal(
                    True,
                    initial_wrapped=result,
                    initial_length=initial_length,
                    debug_reason="template"
                )
            )

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        parameters = {}
        parameters.update({
            "key_ast{}".format(id(key)): key.to_ast(context_name, dependency_builder)
            for key, opcode in self.operands
        })
        parameters.update({
            "value_ast{}".format(id(opcode)): opcode.to_ast(context_name, dependency_builder)
            for key, opcode in self.operands
        })
        parameter_template = ",".join("{{key_ast{}}}: {{value_ast{}}}".format(id(key), id(opcode)) for key, opcode in self.operands)
        return compile_expression(
            "Universal(True, initial_wrapped={{ " + parameter_template + " }}, initial_length=CALCULATE_INITIAL_LENGTH)",
            context_name, dependency_builder, **parameters
        )

class ContextOp(Opcode):
    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add(self, "value", get_context_type(context))
        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(self, context)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression(context_name, context_name, dependency_builder)

    def __str__(self):
        return "Context"


class DereferenceOp(OpcodeOperandMixin, Opcode):
    INVALID_OF = TypeErrorFactory("DereferenceOp: invalid_of")
    INVALID_DEREFERENCE = TypeErrorFactory("DereferenceOp: invalid_dereference")

    of = Operand(CompositeType({}, "DereferenceOp"), INVALID_OF)
    reference = Operand(AnyType(), None)

    def __init__(self, data, visitor):
        super(DereferenceOp, self).__init__(data, visitor)
        self.binder = MicroOpBinder()
        self.generates_exceptions = True

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        self.reference.prepare(break_types, context, frame_manager, hooks, immediate_context)
        self.of.prepare(break_types, context, frame_manager, hooks, immediate_context)

        self.generates_exceptions = False

        invalid_dereferences = set()
        invalid_unknown_dereference = False

        for reference, of_type in each_reference(self.reference.value_type, self.of.value_type):
            if reference is MISSING:
                # We don't know what the reference is at verification time - it might be
                # dynamic like an index into an array. Use wildcard microop and check for errors
                micro_op = self.binder.bind(None, [
                    ("get-wildcard",)
                ], of_type)                    
            else:
                # We know what the reference might be at verification time - attempt static
                # binding and fallback on wildcard microop, again checking for errors
                micro_op = self.binder.bind(reference, [
                    ("get", reference), ("get-wildcard",)
                ], of_type)

            if micro_op:
                break_types.add(self, "value", micro_op.value_type)
            else:
                break_types.add(self, "value", AnyType())

            if not micro_op or micro_op.type_error or micro_op.key_error:
                if reference is MISSING:
                    invalid_unknown_dereference = True
                else:
                    invalid_dereferences.add(reference)

        for invalid_dereference in invalid_dereferences:
            break_types.add(self, "exception", self.INVALID_DEREFERENCE.get_type(
                message="DereferenceOp: invalid_dereference".format(invalid_dereference)
            ))
        if invalid_unknown_dereference:
            break_types.add(self, "exception", self.INVALID_DEREFERENCE.get_type())

        self.generates_exceptions = len(invalid_dereferences) > 0 or invalid_unknown_dereference

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            of = self.of.get(context, frame, hooks)
            reference = self.reference.get(context, frame, hooks)

            manager = get_manager(of)

            if manager is None:
                return frame.exception(self, self.INVALID_DEREFERENCE(reference=reference))

            try:
                tag, micro_op = self.binder.get(
                    [ reference, None ]
                )

                if micro_op is None:
                    # Runtime dynamic behaviour! We weren't even able to bind to the
                    # wildcard microop at verification time (maybe we didn't know whether
                    # the target would be a CompositeType). No harm though - we get the
                    # microop at runtime instead.
                    tag, micro_op = get_best_micro_op([
                        ("get", reference), ("get-wildcard",)
                    ], manager.get_effective_composite_type())

                direct = tag and tag[0] != "get-wildcard"

                if not micro_op:                    
                    return frame.exception(self, self.INVALID_DEREFERENCE(reference=reference))

                result = None

                if direct:
                    result = micro_op.invoke(manager, shortcut_checks=True)
                else:
                    result = micro_op.invoke(manager, reference, shortcut_checks=True)

                if result is SPARSE_ELEMENT:
                    return frame.exception(self, self.INVALID_DEREFERENCE(reference=reference))

                return frame.value(self, result)
            except InvalidDereferenceType:
                return frame.exception(self, self.INVALID_DEREFERENCE(
                    message="DereferenceOp: invalid_dereference"
                ))
            except InvalidDereferenceKey:
                return frame.exception(self, self.INVALID_DEREFERENCE(
                    message="DereferenceOp: invalid_dereference"
                ))

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        tag, micro_op_to_compile = self.binder.simple_bind()

        need_interpreted_version = (
            micro_op_to_compile is None
            or micro_op_to_compile.key_error
            or micro_op_to_compile.type_error
            or self.generates_exceptions
        )

        if need_interpreted_version:
            return super(DereferenceOp, self).to_ast(context_name, dependency_builder)

        direct = tag[0] == "set"

        if not direct:
            reference_ast = self.reference.to_ast(context_name, dependency_builder)
            args = (reference_ast,)
        else:
            args = ()

        return micro_op_to_compile.to_ast(
            dependency_builder,
            self.of.to_ast(context_name, dependency_builder),
            *args
        )

    def __str__(self):
        return "{}.{}".format(self.of, self.reference)


class AssignmentOp(Opcode):
    INVALID_LVALUE = TypeErrorFactory("AssignmentOp: invalid_lvalue")
    INVALID_RVALUE = TypeErrorFactory("AssignmentOp: invalid_rvalue")
    INVALID_ASSIGNMENT = TypeErrorFactory("AssignmentOp: invalid_assignment")

    def __init__(self, data, visitor):
        super(AssignmentOp, self).__init__(data, visitor)
        self.of = enrich_opcode(data._get("of"), visitor)
        self.reference = enrich_opcode(data._get("reference"), visitor)
        self.rvalue = enrich_opcode(data._get("rvalue"), visitor)
        self.binder = MicroOpBinder()
        self.generates_exceptions = True

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        self.generates_exceptions = False

        reference_types = get_operand_type(self.reference, context, frame_manager, hooks, break_types)
        of_types = get_operand_type(self.of, context, frame_manager, hooks, break_types)
        rvalue_type = get_operand_type(self.rvalue, context, frame_manager, hooks, break_types)

        if reference_types is MISSING or of_types is MISSING or rvalue_type is MISSING:
            # If any are missing, then this opcode can not execute
            return break_types.build()

        invalid_assignment_error = invalid_rvalue_error = invalid_lvalue_error = False

        break_types.add(self, "value", NoValueType())

        for reference, of_type in each_reference(reference_types, of_types):
            if reference is MISSING:
                micro_op = self.binder.bind(None, [
                    ("set-wildcard",)
                ], of_type)                    
            else:
                micro_op = self.binder.bind(reference, [
                    ("set", reference), ("set-wildcard",)
                ], of_type)

            if micro_op:
                if not micro_op.value_type.is_copyable_from(rvalue_type, DUMMY_REASONER):
                    invalid_rvalue_error = True

                if micro_op.type_error or micro_op.key_error:
                    invalid_assignment_error = True
            else:
                invalid_lvalue_error = True

        if invalid_assignment_error:
            break_types.add(self, "exception", self.INVALID_ASSIGNMENT.get_type())
        if invalid_rvalue_error:
            break_types.add(self, "exception", self.INVALID_RVALUE.get_type())
        if invalid_lvalue_error:
            break_types.add(self, "exception", self.INVALID_LVALUE.get_type())

        self.generates_exceptions = invalid_assignment_error or invalid_rvalue_error or invalid_lvalue_error

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            of = frame.step("of", lambda: evaluate(self.of, context, frame_manager, hooks))
            reference = frame.step("reference", lambda: evaluate(self.reference, context, frame_manager, hooks))
            rvalue = frame.step("rvalue", lambda: evaluate(self.rvalue, context, frame_manager, hooks))

            manager = get_manager(of)

            try:
                tag, micro_op = self.binder.get([ reference, None ])

                if micro_op is None:
                    # Runtime dynamic behaviour! We weren't even able to bind to the
                    # wildcard microop at verification time (maybe we dind't know whether
                    # the target would be a CompositeType). No harm though - we get the
                    # microop at runtime instead.
                    tag, micro_op = get_best_micro_op([
                        ("set", reference), ("set-wildcard",)
                    ], manager.get_effective_composite_type())

                if not micro_op:
                    return frame.exception(self, self.INVALID_LVALUE())

                if not is_type_bindable_to_value(rvalue, micro_op.value_type):
                    return frame.exception(self, self.INVALID_RVALUE())

                direct = tag[0] != "set-wildcard"

                if direct:
                    micro_op.invoke(manager, rvalue, shortcut_checks=True)
                else:
                    micro_op.invoke(manager, reference, rvalue, shortcut_checks=True)

                return frame.value(self, NO_VALUE)
            except InvalidAssignmentType:
                return frame.exception(self, self.INVALID_ASSIGNMENT())
            except InvalidAssignmentKey:
                return frame.exception(self, self.INVALID_ASSIGNMENT())

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        tag, micro_op_to_compile = self.binder.simple_bind()

        need_interpreted_version = (
            micro_op_to_compile is None
            or micro_op_to_compile.key_error
            or micro_op_to_compile.type_error
            or self.generates_exceptions
        )

        if need_interpreted_version:
            return super(AssignmentOp, self).to_ast(context_name, dependency_builder)

        rvalue_ast = self.rvalue.to_ast(context_name, dependency_builder)

        direct = tag[0] == "set"

        if not direct:
            reference_ast = self.reference.to_ast(context_name, dependency_builder)
            args = (reference_ast, rvalue_ast)
        else:
            args = (rvalue_ast,)

        return micro_op_to_compile.to_ast(
            dependency_builder,
            self.of.to_ast(context_name, dependency_builder),
            *args
        )

class DynamicDereferenceOp(Opcode):
    INVALID_DEREFERENCE = TypeErrorFactory("DynamicDereferenceOp: invalid_dereference {reference}")

    def __init__(self, data, visitor):
        super(DynamicDereferenceOp, self).__init__(data, visitor)
        self.reference = data._get("reference")

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        break_types.add(
            self, 
            "exception",
            self.INVALID_DEREFERENCE.get_type()
        )

        break_types.add(self, "value", AnyType())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            references, _ = frame.step(
                "references",
                lambda: ContextSearcher(context, check_wildcards=True).search_for_reference(self.reference, {})
            )

            if references is None:
                ContextSearcher(context, check_wildcards=True).search_for_reference(self.reference, {})
                return frame.exception(self, self.INVALID_DEREFERENCE())

            target = context
            for reference in [ *references, self.reference ]:
                target_manager = get_manager(target)
                target_type = target_manager.get_effective_composite_type()

                tag, micro_op = get_best_micro_op((("get", reference), ("get-wildcard",)), target_type)

                is_direct = tag[0] != "get-wildcard"

                if is_direct:
                    target = micro_op.invoke(target_manager)
                else:
                    target = micro_op.invoke(target_manager, reference, shortcut_checks=True)

            return frame.value(self, target)

class DynamicAssignmentOp(OpcodeOperandMixin, Opcode):
    INVALID_OF = TypeErrorFactory("DynamicAssignmentOp: invalid_of")
    INVALID_ASSIGNMENT = TypeErrorFactory("DynamicAssignmentOp: invalid_assignment {reference}")

    rvalue = Operand(AnyType(), INVALID_ASSIGNMENT)

    def __init__(self, data, visitor):
        super(DynamicAssignmentOp, self).__init__(data, visitor)
        self.reference = data._get("reference")

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        self.rvalue.prepare(break_types, context, frame_manager, hooks, immediate_context=immediate_context)

        break_types.add(
            self, "exception",
            self.INVALID_ASSIGNMENT.get_type()
        )

        break_types.add(self, "value", NoValueType())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            rvalue = self.rvalue.get(context, frame, hooks)
            references, _ = frame.step(
                "context_links",
                lambda: ContextSearcher(context, check_wildcards=True).search_for_reference(self.reference, {})
            )

            if references is None:
                references = [ "local" ]

            target = context
            for reference in references:
                target_manager = get_manager(target)
                target_type = target_manager.get_effective_composite_type()

                tag, micro_op = get_best_micro_op((("get", reference), ("get-wildcard",)), target_type)

                if micro_op is None:
                    return frame.exception(self, self.INVALID_ASSIGNMENT())

                is_direct = tag[0] != "get-wildcard"

                if is_direct:
                    target = micro_op.invoke(target_manager)
                else:
                    target = micro_op.invoke(target_manager, reference, shortcut_checks=True)

            target_manager = get_manager(target)
            target_type = target_manager.get_effective_composite_type()
            tag, micro_op = get_best_micro_op((("set", self.reference), ("set-wildcard",)), target_type)

            if micro_op is None:
                return frame.exception(self, self.INVALID_ASSIGNMENT())

            is_direct = tag[0] != "set-wildcard"
            if is_direct:
                micro_op.invoke(target_manager, rvalue)
            else:
                micro_op.invoke(target_manager, self.reference, rvalue)

            return frame.value(self, NO_VALUE)


WILDCARD = InternalMarker("WILDCARD")


class InsertOp(Opcode):
    INVALID_LVALUE = TypeErrorFactory("InsertOp: invalid_lvalue")
    INVALID_RVALUE = TypeErrorFactory("InsertOp: invalid_rvalue")
    INVALID_ASSIGNMENT = TypeErrorFactory("InsertOp: invalid_assignment")

    def __init__(self, data, visitor):
        super(InsertOp, self).__init__(data, visitor)
        self.of = enrich_opcode(data._get("of"), visitor)
        self.reference = enrich_opcode(data._get("reference"), visitor)
        self.rvalue = enrich_opcode(data._get("rvalue"), visitor)
        self.micro_ops = {}

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        reference_types, reference_break_types = get_expression_break_types(self.reference, context, frame_manager, hooks)
        break_types.merge(reference_break_types)
        if reference_types is not MISSING:
            reference_types = flatten_out_types(reference_types)

        of_types, of_break_types = get_expression_break_types(self.of, context, frame_manager, hooks)
        break_types.merge(of_break_types)
        if of_types is not MISSING:
            of_types = flatten_out_types(of_types)

        rvalue_type, rvalue_break_types = get_expression_break_types(self.rvalue, context, frame_manager, hooks)
        break_types.merge(rvalue_break_types)
        if rvalue_type is not MISSING:
            rvalue_type = flatten_out_types(rvalue_type)

        self.invalid_assignment_error = self.invalid_rvalue_error = self.invalid_lvalue_error = False

        if reference_types is MISSING or of_types is MISSING or rvalue_type is MISSING:
            return break_types.build()

        for reference_type in unwrap_types(reference_types):
            try:
                possible_references = reference_type.get_all_permitted_values()
            except PermittedValuesDoesNotExist:
                self.invalid_lvalue_error = True
                possible_references = [ WILDCARD ]

            for of_type in unwrap_types(of_types):
                for reference in possible_references:
                    micro_op = None

                    if isinstance(of_type, CompositeType) and reference == 0:
                        micro_op = of_type.get_micro_op_type(("insert-start",))
                        if micro_op:
                            self.micro_ops[reference] = True, micro_op

                    if not micro_op:
                        micro_op = of_type.get_micro_op_type(("insert-wildcard",))
                        if micro_op:
                            self.micro_ops[reference] = False, micro_op

                    if micro_op:
                        if not micro_op.value_type.is_copyable_from(rvalue_type, DUMMY_REASONER):
                            self.invalid_rvalue_error = True

                        break_types.add(self, "value", NoValueType())

                        if micro_op.type_error or micro_op.key_error:
                            self.invalid_assignment_error = True
                    else:
                        self.invalid_lvalue_error = True

        if self.invalid_assignment_error:
            break_types.add(self, "exception", self.INVALID_ASSIGNMENT.get_type())
        if self.invalid_rvalue_error:
            break_types.add(self, "exception", self.INVALID_RVALUE.get_type())
        if self.invalid_lvalue_error:
            break_types.add(self, "exception", self.INVALID_LVALUE.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            of = frame.step("of", lambda: evaluate(self.of, context, frame_manager, hooks))
            reference = frame.step("reference", lambda: evaluate(self.reference, context, frame_manager, hooks))
            rvalue = frame.step("rvalue", lambda: evaluate(self.rvalue, context, frame_manager, hooks))

            manager = get_manager(of)

            try:
                direct, micro_op = self.micro_ops.get(reference, self.micro_ops.get(WILDCARD, (None, None)))
                if self.invalid_lvalue_error and not micro_op:
                    return frame.exception(self, self.INVALID_LVALUE())

                if self.invalid_rvalue_error and not is_type_bindable_to_value(rvalue, micro_op.value_type):
                    return frame.exception(self, self.INVALID_RVALUE())

                if direct:
                    return frame.value(self, micro_op.invoke(manager, rvalue, shortcut_checks=True))
                else:
                    return frame.value(self, micro_op.invoke(manager, reference, rvalue, shortcut_checks=True))

                return frame.exception(self, self.INVALID_LVALUE())
            except InvalidAssignmentType:
                return frame.exception(self, self.INVALID_ASSIGNMENT())
            except InvalidAssignmentKey:
                return frame.exception(self, self.INVALID_ASSIGNMENT())


TOP_CLOSED_FUNCTION_TYPE = ClosedFunctionType(
    BottomType(), {
        "*": [ {
            "out": AnyType()
        } ]
    }
)

BOTTOM_CLOSED_FUNCTION_TYPE = ClosedFunctionType(
    AnyType(), {
        "*": [ {
            "out": BottomType(),
            "in": AnyType()
        } ]
    }
)

class MapOp(OpcodeOperandMixin, Opcode):
    MISSING_COMPOSITE_TYPE = TypeErrorFactory("{}: missing_composite_type")
    MISSING_MAPPER_FUNCTION = TypeErrorFactory("{}: missing_mapper_function")
    MISSING_ITER = TypeErrorFactory("{}: missing_iter")

    composite = Operand(CompositeType({}, "MapOp"), MISSING_COMPOSITE_TYPE)
    mapper = Operand(TOP_CLOSED_FUNCTION_TYPE, MISSING_MAPPER_FUNCTION)

    def __init__(self, data, visitor):
        super(MapOp, self).__init__(data, visitor)
        self.iter_micro_op = None

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        self.composite.prepare(break_types, context, frame_manager, hooks, immediate_context=immediate_context)

        if self.composite.safe:
            self.iter_micro_op = self.composite.value_type.get_micro_op_type(("iter",))

        if self.iter_micro_op:
            immediate_context = immediate_context or {}
            immediate_context["suggested_argument_type"] = UniversalObjectType({
                "index": IntegerType(),
                "key": self.iter_micro_op.key_type,
                "value": self.iter_micro_op.value_type
            })

        # TODO Verify the function can accept the type that we call it with
        self.mapper.prepare(break_types, context, frame_manager, hooks, immediate_context)

        if not self.iter_micro_op:
            break_types.add(self, "exception", self.MISSING_ITER.get_type())

        # Be more liberal: mapper_type might be a OneOfType that includes ClosedFunctionType
        if self.iter_micro_op is not None and self.mapper.safe:
            mapper_break_types = dict(self.mapper.value_type.break_types)

            # TODO: remove break, you can achieve the same with a wrapped transform op
            break_value_type = mapper_break_types.pop("break", MISSING)
            if break_value_type is not MISSING:
                break_types.add(self, "value", break_value_type)

            mapper_continue_type = mapper_break_types.pop("continue", MISSING)
            if mapper_continue_type is not MISSING:
                mapper_continue_type = flatten_out_types(mapper_continue_type)

            ends = mapper_break_types.pop("end", MISSING) is not MISSING
            skips = mapper_break_types.pop("value", MISSING) is not MISSING

            break_types.merge(mapper_break_types)

            every_input_key_is_in_output = not ends and not skips

            micro_ops = {}

            keys = [ getattr(micro_op, "key", None) for micro_op in self.composite.value_type.get_micro_op_types().values() ]
            integer_keys = [ k for k in keys if isinstance(k, int) ]

            if every_input_key_is_in_output:
                for index in integer_keys:
                    micro_ops[("get", index)] = GetterMicroOpType(index, mapper_continue_type)
                    micro_ops[("set", index)] = GetterMicroOpType(index, AnyType())

            if mapper_continue_type is not MISSING:
                micro_ops[("get-wildcard",)] = GetterWildcardMicroOpType(IntegerType(), mapper_continue_type, True)
                micro_ops[("iter",)] = IterMicroOpType(IntegerType(), mapper_continue_type)

            micro_ops[("set-wildcard",)] = SetterWildcardMicroOpType(IntegerType(), AnyType(), True, False)
            micro_ops[("remove-wildcard",)] = RemoverWildcardMicroOpType(True, False)
            micro_ops[("insert-wildcard",)] = InserterWildcardMicroOpType(AnyType(), True, False)
            micro_ops[("insert-start",)] = InsertStartMicroOpType(AnyType(), False)
            micro_ops[("insert-end",)] = InsertEndMicroOpType(AnyType(), False)
            micro_ops[("delete-wildcard",)] = DeletterWildcardMicroOpType(IntegerType(), True)

            result = CompositeType(micro_ops, name="MapOp")
            break_types.add(self, "value", result)

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            composite = self.composite.get(context, frame, hooks)
            mapper = self.mapper.get(context, frame, hooks)

            with frame_manager.capture("break") as breaker:
                results = frame.step("results", lambda: [])

                composite_manager = get_manager(composite)

                # TODO: Make restartable - can not yet be used in a continuation
                for i, k, v in self.iter_micro_op.invoke(composite_manager):
                    with frame_manager.capture("end") as ender:
                        with frame_manager.capture("continue") as capturer:
                            with frame_manager.capture("value"):
                                args = PythonObject({
                                    "index": i,
                                    "key": k,
                                    "value": v
                                })
                                mapper.invoke(args, frame_manager, hooks)
                        if capturer.value is not None:
                            results.append(capturer.value)
                    if ender.value is not None:
                        break
                return frame.value(self, PythonList(results))
            if breaker.value is not None:
                return frame.value(self, breaker.value)

            raise FatalError()


class LengthOp(OpcodeOperandMixin, Opcode):
    INVALID_COMPOSITE_TYPE = TypeErrorFactory("{}: invalid_composite_type")
    composite = Operand(CompositeType({}, "LengthOp"), INVALID_COMPOSITE_TYPE)

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        can_run = True
        can_run = can_run and self.composite.prepare(break_types, context, frame_manager, hooks, immediate_context)

        if can_run:
            break_types.add(self, "value", IntegerType())

        return break_types.build()

    @abstractmethod
    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(self, 
                self.composite.get(context, frame, hooks)._length
            )


def BinaryOp(name, func, argument_type, result_type, number_op=None, cmp_op=None):
    MISSING_OPERANDS = TypeErrorFactory("{}: missing_operands".format(name))

    class _BinaryOp(OpcodeOperandMixin, Opcode):
        lvalue = Operand(argument_type, MISSING_OPERANDS)
        rvalue = Operand(argument_type, MISSING_OPERANDS)

        def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
            break_types = BreakTypesFactory(self)

            can_run = True
            can_run = can_run and self.lvalue.prepare(break_types, context, frame_manager, hooks, immediate_context)
            can_run = can_run and self.rvalue.prepare(break_types, context, frame_manager, hooks, immediate_context)

            if can_run:
                break_types.add(self, "value", result_type)

            return break_types.build()

        def jump(self, context, frame_manager, hooks, immediate_context=None):
            with frame_manager.get_next_frame(self) as frame:
                return frame.value(self, 
                    func(
                        self.lvalue.get,
                        self.rvalue.get,
                        context,
                        frame,
                        hooks
                    )
                )

        def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
            if self.lvalue.safe and self.rvalue.safe:
                if number_op:
                    lvalue_ast = self.lvalue.to_ast(context_name, dependency_builder)
                    rvalue_ast = self.rvalue.to_ast(context_name, dependency_builder)
                    return ast.BinOp(left=lvalue_ast, right=rvalue_ast, op=number_op)
                elif cmp_op:
                    lvalue_ast = self.lvalue.to_ast(context_name, dependency_builder)
                    rvalue_ast = self.rvalue.to_ast(context_name, dependency_builder)
                    return ast.Compare(left=lvalue_ast, ops=[ cmp_op ], comparators=[ rvalue_ast ])

            return Opcode.to_ast(self, context_name, dependency_builder)

    return _BinaryOp


class TransformOp(Opcode):
    def __init__(self, data, visitor):
        super(TransformOp, self).__init__(data, visitor)
        if self.data._contains("code"):
            self.expression = enrich_opcode(self.data._get("code"), visitor)
            if not self.data._contains("input"):
                raise PreparationException("input missing in transform opcode")
            self.input = self.data._get("input")
            self.immediate_child = self.data._get("immediate_child", False)
        else:
            self.expression = None
            self.input = None

        if not self.data._contains("output"):
            raise PreparationException("output missing in transform opcode")
        self.output = self.data._get("output")

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        if self.expression:
            expression_break_types = dict(self.expression.get_break_types(context, frame_manager, hooks))
            all_inputs = transformed_inputs = expression_break_types.pop(self.input, [])
            remaining_inputs = []

            if self.immediate_child:
                transformed_inputs = [ i for i in all_inputs if i.get("opcode", None) is self.expression ]
                remaining_inputs = [ i for i in all_inputs if i.get("opcode", None) is not self.expression ]

            transformed_inputs = [{
                **i,
                "opcode": self
            } for i in transformed_inputs]

            expression_break_types[self.input] = remaining_inputs
            expression_break_types[self.output] = [
                *expression_break_types.get(self.output, []),
                *transformed_inputs
            ]

            break_types.merge(expression_break_types)
        else:
            break_types.add(self, self.output, NoValueType())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            if self.expression:
                opcode = self.expression if self.immediate_child else None
                with frame_manager.capture(break_mode=self.input, opcode=opcode) as capture_result:
                    capture_result.attempt_capture_or_raise(*self.expression.jump(context, frame_manager, hooks))

                return frame.unwind(*capture_result.reraise(opcode=self, break_mode=self.output))
            else:
                return frame.unwind(self, self.output, NO_VALUE, None)
        raise FatalError()

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if self.expression is None:
            return compile_statement("""
raise BreakException("{output}", NoValue, {opcode}, None)
                """, context_name, dependency_builder,
                output=self.output,
                opcode=self
            )

        expression_ast = self.expression.to_ast(
            context_name,
            dependency_builder,
            will_ignore_return_value=will_ignore_return_value and self.input != "value"
        )

        if self.input == "value":
            return compile_statement("""
raise BreakException("{output}", {expression}, {opcode}, None)
                """, context_name, dependency_builder,
                output=self.output,
                expression=expression_ast,
                opcode=self
            )
        elif self.output == "value":
            if will_ignore_return_value:
                return compile_statement("""
try:
    {expression}
except BreakException as b:
    if b.mode != "{input}":
        raise
                    """, context_name, dependency_builder,
                    input=self.input,
                    expression=expression_ast
                )
            else:
                try_catcher = compile_statement("""
def TransformOpTryCatcher{opcode_id}({context_name}, _frame_manager, _hooks):
    try:
        return {expression}
    except BreakException as b:
        if b.mode == "{input}":
            return b.value
        raise
                    """, context_name, dependency_builder,
                    opcode_id=dependency_builder.get_next_id(),
                    input=self.input,
                    expression=expression_ast
                )

                return compile_expression("""
{try_catcher}({context_name}, _frame_manager, _hooks)
                    """, context_name, dependency_builder,
                    try_catcher=try_catcher
                )
        else:
            return super(TransformOp, self).to_ast(context_name, dependency_builder)


class ShiftOp(Opcode):
    def __init__(self, data, visitor):
        super(ShiftOp, self).__init__(data, visitor)
        self.opcode = enrich_opcode(data._get("code"), visitor)
        self.restart_type = enrich_opcode(data._get("restart_type"), visitor)

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        value_type, other_break_types = get_expression_break_types(self.opcode, context, frame_manager, hooks, immediate_context) 

        restart_type_value = evaluate(self.restart_type, context, frame_manager, hooks)
        with scoped_bind(restart_type_value, DEFAULT_READONLY_COMPOSITE_TYPE):
            self.restart_type = enrich_type(restart_type_value)

        value_type = flatten_out_types(value_type)
        break_types.merge(other_break_types)

        break_types.add(self, "yield", value_type, self.restart_type)
        break_types.add(self, "value", self.restart_type)

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            if frame.has_restart_value():
                restart_value = frame.pop_restart_value()

                if get_environment().validate_flow_control:
                    if not self.restart_type.is_copyable_from(get_type_of_value(restart_value), DUMMY_REASONER):
                        raise FatalError()

                return frame.unwind(self, "value", restart_value, None)

            value = evaluate(self.opcode, context, frame_manager, hooks)

            return frame.yield_(self, value, self.restart_type)


class ResetOp(Opcode):
    MISSING_IN_BREAK_TYPE = TypeErrorFactory("ResetOp: missing_in_break_type")
    MISSING_FUNCTION = TypeErrorFactory("ResetOp: missing_function")

    def __init__(self, data, visitor):
        super(ResetOp, self).__init__(data, visitor)
        if hasattr(data, "code"):
            self.opcode = enrich_opcode(data._get("code"), visitor)
            self.function = None
            self.argument = None
        else:
            self.opcode = None
            self.function = enrich_opcode(data._get("function"), visitor)
            self.argument = enrich_opcode(data._get("argument"), visitor)

    def get_value_and_continuation_block_type(self, out_break_type, in_break_type, continuation_break_types):
        return UniversalObjectType({
            "value": Const(out_break_type),
            "continuation": Const(ClosedFunctionType(in_break_type, continuation_break_types))
        }, name="ValueAndContinuation")

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        yield_break_types = []
        self.continuation_break_types = None

        if self.opcode:
            opcode_break_types = dict(self.opcode.get_break_types(context, frame_manager, hooks))
            self.continuation_break_types = dict(opcode_break_types)
            yield_break_types = opcode_break_types.pop("yield", [])
            break_types.merge(opcode_break_types)
        else:
            function_type, function_break_types = get_expression_break_types(self.function, context, frame_manager, hooks)
            if function_type is not MISSING:
                function_type = flatten_out_types(function_type)
            break_types.merge(function_break_types)

            if isinstance(function_type, ClosedFunctionType): 
                self.continuation_break_types = function_type.break_types
                function_break_types = dict(function_type.break_types)
                yield_break_types = function_break_types.pop("yield", [])
                break_types.merge(function_break_types)
            else:
                break_types.add(self, "exception", self.MISSING_FUNCTION.get_type())

        missing_in_error = False

        for yield_break_type in yield_break_types:
            if "in" not in yield_break_type:
                missing_in_error = True
            else:
                break_types.add(
                    self,
                    "yield",
                    self.get_value_and_continuation_block_type(
                        yield_break_type["out"], yield_break_type["in"], self.continuation_break_types
                    )
                )

        if missing_in_error:
            break_types.add(self, "exception", self.MISSING_IN_BREAK_TYPE.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        from lockdown.executor.function import Continuation

        with frame_manager.get_next_frame(self) as frame:
            if self.opcode:
                def enter_expression():
                    return self.opcode.jump(context, frame_manager, hooks)
                with frame_manager.capture("yield") as capture_result:
                    capture_result.attempt_capture_or_raise(*enter_expression())

                if capture_result.caught_frames is None:
                    return frame.exception(self, self.MISSING_IN_BREAK_TYPE())

                restart_continuation = capture_result.create_continuation(
                    enter_expression, self.continuation_break_types
                )
            else:
                argument = frame.step("argument", lambda: evaluate(self.argument, context, frame_manager, hooks))
                function = frame.step("function", lambda: evaluate(self.function, context, frame_manager, hooks))

                def enter_function():
                    return function.invoke(argument, frame_manager, hooks)

                with frame_manager.capture("yield") as capture_result:
                    capture_result.attempt_capture_or_raise(*enter_function())

                if capture_result.caught_frames is None:
                    return frame.exception(self, self.MISSING_IN_BREAK_TYPE())

                if isinstance(function, Continuation):
                    # Avoid using enter_function as the callback, hook into the original
                    # continuation callback, avoiding an infinite chain of linked callbacks.
                    restart_continuation = capture_result.create_continuation(
                        function.callback, self.continuation_break_types
                    )
                else:
                    restart_continuation = capture_result.create_continuation(
                        enter_function, self.continuation_break_types
                    )

            restart_continuation_type = restart_continuation.get_type()

            result = PythonObject({
                "value": capture_result.value,
                "continuation": restart_continuation
            }, bind=self.get_value_and_continuation_block_type(
                get_type_of_value(capture_result.value),
                restart_continuation_type.argument_type,
                restart_continuation_type.break_types
            ))

            return frame.yield_(self, result, None)


class CommaOp(OpcodeOperandMixin, Opcode):
    def __init__(self, data, visitor):
        super(CommaOp, self).__init__(data, visitor)
        self.operands = [
            BoundOperand(
                i,
                self,
                enrich_opcode(o, visitor),
                AnyType(),
                None
            ) for i, o in enumerate([ opcode for opcode in data._get("opcodes")._to_list() ])
        ]

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        can_run = True
        for operand in self.operands:
            can_run = can_run and operand.prepare(break_types, context, frame_manager, hooks, immediate_context)

        if can_run:
            break_types.add(self, "value", self.operands[-1].value_type)

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        value = NO_VALUE
        with frame_manager.get_next_frame(self) as frame:
            for opcode in self.operands:
                value = opcode.get(context, frame, hooks)

            return frame.value(self, value)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        asts = [
            e.to_ast(context_name, dependency_builder, will_ignore_return_value if i == len(self.operands) - 1 else True)
            for i, e in enumerate(self.operands)
        ]
        if will_ignore_return_value:
            asts = unwrap_modules(asts)
            asts = [wrap_as_statement(a) for a in asts]
            return ast.Module(body=asts)
        else:
            asts = unwrap_modules(asts)
            asts[-1] = compile_statement(
                "return {ast}",
                context_name, dependency_builder, ast=asts[-1]
            )
            asts = [wrap_as_statement(a) for a in asts]
            ast_placeholders = [ ("ast_{}_{}".format(id(self), id(e_ast)), e_ast) for e_ast in asts ]
            comma_function = compile_statement(
                "def CommaOp{opcode_id}({context_name}, _frame_manager, _hooks):\n\t{" + "}\n\t{".join([ k for (k, _) in ast_placeholders ]) + "}",
                context_name, dependency_builder, opcode_id=id(self), **dict(ast_placeholders)
            )
            return compile_expression(
                "{comma_function}({context_name}, _frame_manager, _hooks)",
                context_name, dependency_builder, comma_function=comma_function
            )


class LoopOp(Opcode):
    def __init__(self, data, visitor):
        self.code = enrich_opcode(data._get("code"), visitor)
        self.has_continues = True
        self.has_ends = True
        self.has_breaks = True  # TODO remove - this can be achieved with a outer TransformOp

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        _, other_break_types = get_expression_break_types(self.code, context, frame_manager, hooks)
        continue_value_type = other_break_types.pop("continue", MISSING)
        end_break = other_break_types.pop("end", MISSING)
        mode_break_type = other_break_types.pop("break", MISSING)

        self.has_continues = continue_value_type is not MISSING
        self.has_ends = end_break is not MISSING
        self.has_breaks = mode_break_type is not MISSING

        if end_break is not MISSING:
            # The loop might end gracefully
            if continue_value_type is not MISSING:
                # The loop will generate continue values before ending, so we
                # know it will return a list of elements
                continue_value_type = flatten_out_types(continue_value_type)
                break_types.add(self, "value", UniversalListType(continue_value_type))
            else:
                # The loop will not generate continue values before ending,
                # so it will generate an empty Tuple
                break_types.add(self, "value", UniversalTupleType([]))

        if mode_break_type is not MISSING:
            # The loop might break out suddenly with a value
            mode_break_type = flatten_out_types(mode_break_type)
            break_types.add(self, "value", mode_break_type)

        break_types.merge(other_break_types)
        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        results = []

        with frame_manager.get_next_frame(self) as frame:
            with frame_manager.capture("break") as breaker:
                while True:
                    with frame_manager.capture("end") as ender:
                        with frame_manager.capture("continue") as capturer:
                            evaluate(self.code, context, frame_manager, hooks)
                        if capturer.value is not None:
                            results.append(capturer.value)
                    if ender.value is not None:
                        return frame.value(self, PythonList(results))
            if breaker.value is not None:
                return frame.value(self, breaker.value)

        raise FatalError()

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if not will_ignore_return_value:
            return super(LoopOp, self).to_ast(context_name, dependency_builder)
        else:
            return compile_statement("""
try:
    while True:
        try:
            {expression}
        except BreakException as e:
            if e.mode == "continue":
                pass
            raise
except BreakException as e:
    if e.mode not in ("end", "break"):
        raise
    """,
                context_name,
                dependency_builder,
                expression=self.code.to_ast(context_name, dependency_builder, will_ignore_return_value=True)
            )


class ConditionalOp(OpcodeOperandMixin, Opcode):
    INVALID_CONDITIONAL = TypeErrorFactory("ConditionalOp: invalid_conditional")
    condition = Operand(BooleanType(), INVALID_CONDITIONAL)
    when_true = Operand(AnyType(), None)
    when_false = Operand(AnyType(), None)

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        if self.condition.prepare(break_types, context, frame_manager, hooks, immediate_context):
            if self.condition.value_type.is_copyable_from(UnitType(True), DUMMY_REASONER):
                if self.when_true.prepare(break_types, context, frame_manager, hooks,immediate_context):
                    break_types.add(self, "value", self.when_true.value_type)
            if self.condition.value_type.is_copyable_from(UnitType(False), DUMMY_REASONER):
                if self.when_false.prepare(break_types, context, frame_manager, hooks, immediate_context):
                    break_types.add(self, "value", self.when_false.value_type)

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            condition = self.condition.get(context, frame, hooks)

            if condition is True:
                result = self.when_true.get(context, frame, hooks)
            elif condition is False:
                result = self.when_false.get(context, frame, hooks)
            else:
                raise FatalError()

            return frame.value(self, result)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if will_ignore_return_value:
            return compile_statement("""
if {condition}:
    {when_true}
else:
    {when_false}
                """, context_name, dependency_builder,
                condition=self.condition.to_ast(context_name, dependency_builder),
                when_true=self.when_true.to_ast(context_name, dependency_builder),
                when_false=self.when_false.to_ast(context_name, dependency_builder)
            )

        else:
            return compile_expression("""
{when_true} if {condition} else {when_false}
                """, context_name, dependency_builder,
                condition=self.condition.to_ast(context_name, dependency_builder),
                when_true=self.when_true.to_ast(context_name, dependency_builder),
                when_false=self.when_false.to_ast(context_name, dependency_builder)
            )


class PrepareOp(Opcode):
    PREPARATION_ERROR = TypeErrorFactory("Prepare: preparation_error")

    def __init__(self, data, visitor):
        super(PrepareOp, self).__init__(data, visitor)
        self.code = enrich_opcode(data._get("code"), visitor)

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        function_value_type, other_break_types = get_expression_break_types(self.code, context, frame_manager, hooks, immediate_context)

        break_types.merge(other_break_types)

        if function_value_type is not MISSING:
            break_types.add(self, 
                "value", AnyType()  # OpenFunctionType(BottomType(), get_context_type(context), {})
            )

        break_types.add(self, "exception", self.PREPARATION_ERROR.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            function_data = evaluate(self.code, context, frame_manager, hooks)

            from lockdown.executor.function import prepare

            immediate_context = immediate_context or {}
            immediate_context["suggested_outer_type"] = get_context_type(context)

            try:
                function = prepare(function_data, context, frame_manager, hooks, immediate_context)
            except PreparationException as e:
                return frame.exception(self, self.PREPARATION_ERROR(exception=str(e)))

            return frame.value(self, function)


class CloseOp(Opcode):
    INVALID_FUNCTION = TypeErrorFactory("Close: invalid_function")
    INVALID_OUTER_CONTEXT = TypeErrorFactory("Close: invalid_outer_context")

    def __init__(self, data, visitor):
        super(CloseOp, self).__init__(data, visitor)
        self.function = enrich_opcode(data._get("function"), visitor)
        self.outer_context = enrich_opcode(data._get("outer_context"), visitor)

        self.outer_context_type_error = True

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        function_type, function_break_types = get_expression_break_types(self.function, context, frame_manager, hooks, immediate_context=immediate_context)
        if function_type is not MISSING:
            function_type = flatten_out_types(function_type)
        break_types.merge(function_break_types)

        outer_context_type, outer_context_break_types = get_expression_break_types(self.outer_context, context, frame_manager, hooks, immediate_context=immediate_context)
        outer_context_type = flatten_out_types(outer_context_type)
        break_types.merge(outer_context_break_types)

        if function_type is not MISSING and outer_context_type is not MISSING:
            if isinstance(function_type, OpenFunctionType):
                break_types.add(self, "value", ClosedFunctionType(function_type.argument_type, function_type.break_types))
                if function_type.outer_type.is_copyable_from(outer_context_type, DUMMY_REASONER):
                    self.outer_context_type_error = False
            else:
                break_types.add(self, "value", AnyType())

        if self.outer_context_type_error:
            break_types.add(self, "exception", self.INVALID_OUTER_CONTEXT.get_type())

        if not isinstance(function_type, OpenFunctionType):
            break_types.add(self, "exception", self.INVALID_FUNCTION.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            open_function = frame.step("function", lambda: evaluate(self.function, context, frame_manager, hooks, immediate_context))
            outer_context = frame.step("outer", lambda: evaluate(self.outer_context, context, frame_manager, hooks, immediate_context))

            from lockdown.executor.function import OpenFunction

            if not isinstance(open_function, OpenFunction):
                return frame.exception(self, self.INVALID_FUNCTION())

            if (get_environment().opcode_bindings or self.outer_context_type_error):
                reasoner = Reasoner()
                if not does_value_fit_through_type(outer_context, open_function.outer_type, reasoner):
                    print(reasoner)
                    does_value_fit_through_type(outer_context, open_function.outer_type, reasoner)
                    return frame.exception(self, self.INVALID_OUTER_CONTEXT())

            return frame.value(self, open_function.close(outer_context))

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression("""
{open_function}.close({outer_context})
            """, context_name, dependency_builder,
            open_function=self.function.to_ast(context_name, dependency_builder),
            outer_context=self.outer_context.to_ast(context_name, dependency_builder)
        )


def create_readonly_static_type(value):
    """
    For the StaticOp, for a given static value, produces a Type that opcodes
    that refer to the value from StaticOp are able to run against.
    """
    if isinstance(value, Composite):
        #return DEFAULT_READONLY_COMPOSITE_TYPE
        # Only do ListTypes atm since that is what is needed for unit tests, but can be expanded...
        result = CompositeType({}, name="reasonable list type")
        if isinstance(value, Universal):
            types_of_values = [ create_readonly_static_type(v) for v in value._values() ]
            merged_types = merge_types(types_of_values, "exact")

            for key, type_of_value in zip(value._keys(), types_of_values):
                result.set_micro_op_type(("get", key), GetterMicroOpType(key, type_of_value))

            result.set_micro_op_type(("get-wildcard",), GetterWildcardMicroOpType(IntegerType(), merged_types, True))
            result.set_micro_op_type(("iter",), IterMicroOpType(IntegerType(), merged_types))
        return result
    else:
        return get_type_of_value(value)


class StaticOp(Opcode):
    def __init__(self, data, visitor):
        super(StaticOp, self).__init__(data, visitor)
        self.code = enrich_opcode(data._get("code"), visitor)
        self.value = MISSING

    def lazy_initialize(self, context, frame_manager, hooks, immediate_context):
        if self.value is MISSING:
            self.value = evaluate(self.code, context, frame_manager, hooks, immediate_context)

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        self.lazy_initialize(context, frame_manager, hooks, immediate_context)
        break_types.add(self, "value", create_readonly_static_type(self.value))
        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            from lockdown.executor.function import OpenFunction
            self.lazy_initialize(context, frame_manager, hooks, immediate_context)
            return frame.unwind(self, "value", self.value, None)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression(
            "{static_value}",
            context_name,
            dependency_builder,
            static_value=self.value
        )


class InvokeOp(Opcode):
    INVALID_FUNCTION_TYPE = TypeErrorFactory("Invoke: invalid_function_type")
    INVALID_ARGUMENT_TYPE = TypeErrorFactory("Invoke: invalid_argument_type")
    INVALID_BREAK_TYPE = TypeErrorFactory("Invoke: invalid_break_type")

    def __init__(self, data, visitor):
        super(InvokeOp, self).__init__(data, visitor)
        self.function = enrich_opcode(data._get("function"), visitor)
        self.argument = enrich_opcode(data._get("argument"), visitor)
        self.invalid_argument_type_exception_is_possible = True
        self.known_function_type = False
        self.allowed_break_modes = data._get("allowed_break_modes")._to_list()

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)

        immediate_context = {}
        argument_type, other_argument_break_types = get_expression_break_types(self.argument, context, frame_manager, hooks)
        if argument_type is not MISSING:
            argument_type = flatten_out_types(argument_type)
            immediate_context["suggested_argument_type"] = argument_type
        break_types.merge(other_argument_break_types)

        function_type, other_function_break_types = get_expression_break_types(
            self.function, context, frame_manager, hooks, immediate_context=immediate_context
        )
        break_types.merge(other_function_break_types)

        if function_type is not MISSING and argument_type is not MISSING:
            function_type = flatten_out_types(function_type)

            if isinstance(function_type, ClosedFunctionType):
                self.known_function_type = True
                break_types.merge({
                    break_mode: [{
                        **break_type,
                        "opcode": self
                    } for break_type in sub_break_types]
                    for break_mode, sub_break_types in function_type.break_types.items()
                })
                reasoner = Reasoner()
                if function_type.argument_type.is_copyable_from(argument_type, reasoner):
                    self.invalid_argument_type_exception_is_possible = False
            else:
                break_types.add(self, "exception", self.INVALID_FUNCTION_TYPE.get_type())
                break_types.add(self, "exception", self.INVALID_BREAK_TYPE.get_type())

                for allowed_break_mode in self.allowed_break_modes:
                    break_types.add(self, allowed_break_mode, AnyType())

            if self.invalid_argument_type_exception_is_possible:
                break_types.add(self, "exception", self.INVALID_ARGUMENT_TYPE.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        from lockdown.executor.function import LockdownFunction

        with frame_manager.get_next_frame(self) as frame:
            function = frame.step("function", lambda: evaluate(self.function, context, frame_manager, hooks))
            argument = frame.step("argument", lambda: evaluate(self.argument, context, frame_manager, hooks))

            if not isinstance(function, LockdownFunction):
                return frame.exception(self, self.INVALID_FUNCTION_TYPE())
            if self.invalid_argument_type_exception_is_possible and not does_value_fit_through_type(argument, function.get_type().argument_type):
                return frame.exception(self, self.INVALID_ARGUMENT_TYPE()) 

            with frame_manager.capture() as capture_result:
                capture_result.attempt_capture_or_raise(*function.invoke(argument, frame_manager, hooks))

            if not self.known_function_type:
                if capture_result.caught_break_mode not in self.allowed_break_modes:
                    return frame.exception(self, self.INVALID_BREAK_TYPE())

            return frame.unwind(*capture_result.reraise(opcode=self))

        raise FatalError()

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        from lockdown.executor.function import OpenFunction
        if (isinstance(self.function, CloseOp)
            and isinstance(self.function.function, StaticOp)
            and isinstance(self.function.function.value, OpenFunction)
        ):
            open_function = self.function.function.value
            if will_ignore_return_value:
                # to_inline_ast can return None if it's not possible to inline the open function
                inline_ast = open_function.to_inline_ast(
                    dependency_builder,
                    self.function.outer_context.to_ast(context_name, dependency_builder),
                    self.argument.to_ast(context_name, dependency_builder)
                )
                if inline_ast:
                    return inline_ast

            # return compile_expression(
            #     "{function}.close_and_invoke({argument}, {outer_context}, _frame_manager, _hooks)[1]",
            #     context_name, dependency_builder,
            #     function=open_function,
            #     outer_context=self.function.outer_context.to_ast(context_name, dependency_builder),
            #     argument=self.argument.to_ast(context_name, dependency_builder)
            # )
        return compile_expression(
            "{function}.invoke({argument}, _frame_manager, _hooks)[1]",
            context_name, dependency_builder,
            function=self.function.to_ast(context_name, dependency_builder),
            argument=self.argument.to_ast(context_name, dependency_builder)
        )


class MatchOp(Opcode):
    NO_MATCH = TypeErrorFactory("Match: no_match")

    def __init__(self, data, visitor):
        super(MatchOp, self).__init__(data, visitor)
        self.value = enrich_opcode(data._get("value"), visitor)
        self.matchers = [ enrich_opcode(m, visitor) for m in data._get("matchers")._to_list() ]

        if not get_environment().rtti:
            raise FatalError("RTTI is required for MatchOp")

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        value_type, value_break_types = get_expression_break_types(self.value, context, frame_manager, hooks)
        value_type = flatten_out_types(value_type)

        break_types.merge(value_break_types)

        for matcher in self.matchers:
            matcher_function_type, matcher_break_types = get_expression_break_types(
                matcher,
                context,
                frame_manager,
                hooks,
                immediate_context={ "suggested_argument_type": value_type }
            )
            matcher_function_type = flatten_out_types(matcher_function_type)

            break_types.merge(matcher_break_types)
            break_types.merge(matcher_function_type.break_types)

            if matcher_function_type.argument_type.is_copyable_from(value_type, DUMMY_REASONER):
                break

            value_type = remove_type(value_type, matcher_function_type.argument_type)
        else:
            break_types.add(self, "exception", self.NO_MATCH.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            value = frame.step("value", lambda: evaluate(self.value, context, frame_manager, hooks))

            for index, matcher in enumerate(self.matchers):
                matcher_function = frame.step(index, lambda: evaluate(matcher, context, frame_manager, hooks))
                if is_type_bindable_to_value(value, matcher_function.get_type().argument_type):
                    return matcher_function.invoke(value, frame_manager, hooks)
            else:
                return frame.exception(self, self.NO_MATCH())

        raise FatalError()


class PrintOp(Opcode):
    def __init__(self, data, visitor):
        super(PrintOp, self).__init__(data, visitor)
        self.expression = enrich_opcode(data._get("expression"), visitor)

    def get_break_types(self, context, frame_manager, hooks, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add(self, "value", NoValueType())
        return break_types.build()

    def jump(self, context, frame_manager, hooks, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            print(evaluate(self.expression, context, frame_manager, hooks))
            return frame.value(self, NO_VALUE)


FLOW_CONTROL_OPCODES = {
    "nop": Nop,
    "transform": TransformOp,
    "shift": ShiftOp,
    "reset": ResetOp,
    "comma": CommaOp,
    "loop": LoopOp,
    "conditional": ConditionalOp,
}

MATH_AND_LOGIC_OPCODES = {
    "multiplication": BinaryOp(
        "Multiplication",
        lambda lvalue, rvalue, *args: lvalue(*args) * rvalue(*args), IntegerType(), IntegerType(), number_op=ast.Mult()
    ),
    "division": BinaryOp(
        "Division",
        lambda lvalue, rvalue, *args: lvalue(*args) // rvalue(*args), IntegerType(), IntegerType(), number_op=ast.FloorDiv()
    ),
    "addition": BinaryOp(
        "Addition",
        lambda lvalue, rvalue, *args: lvalue(*args) + rvalue(*args), IntegerType(), IntegerType(), number_op=ast.Add()
    ),
    "subtraction": BinaryOp(
        "Subtraction",
        lambda lvalue, rvalue, *args: lvalue(*args) - rvalue(*args), IntegerType(), IntegerType(), number_op=ast.Sub()
    ),
    "mod": BinaryOp(
        "Modulus",
        lambda lvalue, rvalue, *args: lvalue(*args) % rvalue(*args), IntegerType(), IntegerType()
    ),
    "lt": BinaryOp(
        "LessThan",
        lambda lvalue, rvalue, *args: lvalue(*args) < rvalue(*args), IntegerType(), BooleanType(), cmp_op=ast.Lt()
    ),
    "lte": BinaryOp(
        "LessThanOrEqual",
        lambda lvalue, rvalue, *args: lvalue(*args) <= rvalue(*args), IntegerType(), BooleanType(), cmp_op=ast.LtE()
    ),
    "gt": BinaryOp(
        "GreaterThan",
        lambda lvalue, rvalue, *args: lvalue(*args) > rvalue(*args), IntegerType(), BooleanType(), cmp_op=ast.Gt()
    ),
    "gte": BinaryOp(
        "GreaterThanOrEqual",
        lambda lvalue, rvalue, *args: lvalue(*args) >= rvalue(*args), IntegerType(), BooleanType(), cmp_op=ast.GtE()
    ),
    "eq": BinaryOp(
        "Equality",
        lambda lvalue, rvalue, *args: lvalue(*args) == rvalue(*args), IntegerType(), BooleanType(), cmp_op=ast.Eq()
    ),
    "neq": BinaryOp(
        "Inequality",
        lambda lvalue, rvalue, *args: lvalue(*args) != rvalue(*args), IntegerType(), BooleanType(), cmp_op=ast.NotEq()
    ),
    "or": BinaryOp(
        "Or",
        lambda lvalue, rvalue, *args: lvalue(*args) or rvalue(*args), BooleanType(), BooleanType()
    ),
    "and": BinaryOp(
        "And",
        lambda lvalue, rvalue, *args: lvalue(*args) and rvalue(*args), BooleanType(), BooleanType()
    ),
}

DATA_OPCODES = {
    "dereference": DereferenceOp,
    "dynamic_dereference": DynamicDereferenceOp,
    "assignment": AssignmentOp,
    "dynamic_assignment": DynamicAssignmentOp,
    "literal": LiteralOp,
    "template": TemplateOp,
    "insert": InsertOp,
    "map": MapOp,
    "length": LengthOp,
    "context": ContextOp,
    "static": StaticOp,
    "match": MatchOp,
}

FUNCTION_OPCODES = {
    "prepare": PrepareOp,
    "close": CloseOp,
    "invoke": InvokeOp,
}

MISC_OPCODES = {
    "print": PrintOp
}

OPCODES = spread_dict(
    FLOW_CONTROL_OPCODES,
    MATH_AND_LOGIC_OPCODES,
    DATA_OPCODES,
    FUNCTION_OPCODES,
    MISC_OPCODES
)


def enrich_opcode(data, visitor):
    if visitor:
        data = visitor(data)

    opcode = data._get("opcode", MISSING)
    if opcode is MISSING:
        raise PreparationException("No opcode found in {}".format(data))
    if opcode not in OPCODES:
        raise PreparationException("Unknown opcode {} in {}".format(opcode, data))

    return OPCODES[opcode](data, visitor)

