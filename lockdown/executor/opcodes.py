# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from abc import abstractmethod
import ast

from lockdown.executor.ast_utils import compile_expression, compile_statement, \
    unwrap_modules, wrap_as_statement
from lockdown.executor.exceptions import PreparationException
from lockdown.executor.flow_control import BreakTypesFactory, BreakException
from lockdown.executor.function_type import OpenFunctionType, ClosedFunctionType
from lockdown.executor.type_factories import enrich_type
from lockdown.type_system.composites import CompositeType, scoped_bind, \
    does_value_fit_through_type, is_type_bindable_to_value, Composite
from lockdown.type_system.core_types import AnyType, Type, merge_types, Const, \
    UnitType, NoValueType, PermittedValuesDoesNotExist, unwrap_types, IntegerType, \
    BooleanType, remove_type, OneOfType, StringType, BottomType
from lockdown.type_system.exceptions import FatalError, InvalidDereferenceType, \
    InvalidDereferenceKey, InvalidAssignmentType, InvalidAssignmentKey
from lockdown.type_system.managers import get_type_of_value, get_manager
from lockdown.type_system.reasoner import DUMMY_REASONER, Reasoner
from lockdown.type_system.universal_type import UniversalObjectType, \
    DEFAULT_READONLY_COMPOSITE_TYPE, PythonList, UniversalListType, PythonObject, \
    GetterMicroOpType, SetterMicroOpType, GetterWildcardMicroOpType, \
    SetterWildcardMicroOpType, PythonDict, UniversalDictType, \
    InsertStartMicroOpType, InsertEndMicroOpType, DeletterWildcardMicroOpType, \
    IterMicroOpType, RemoverWildcardMicroOpType, InserterWildcardMicroOpType, \
    UniversalTupleType, Universal, SPARSE_ELEMENT
from lockdown.utils.utils import MISSING, NO_VALUE, InternalMarker, get_environment,\
    spread_dict


class Opcode(object):
    """
    Base class for all Opcodes used in Lockdown. 
    """
    def __init__(self, data, visitor):
        self.data = data
        self.break_types = None

    @abstractmethod
    def get_break_types(self, context, frame_manager, immediate_context=None):
        """
        Returns all the break modes and types at verification time. Later, when
        .jump is called, flow can only leave the opcode via the break modes returned
        by this function.

        Returns a dictionary of the different break modes and the associated types for
        each one, that can be generated by this opcode, or by other opcodes invoked by
        this one.
        
        Example, can return:
        {
            "value": [{
                "out": IntegerType()
            }],
            "exception": [{
                "out": TypeError()
            }]
        }
        """
        raise NotImplementedError()

    @abstractmethod
    def jump(self, context, frame_manager, immediate_context=None):
        """
        Entry point for Opcode at run time. We jump into the opcode, and it returns
        by either raising a BreakException, or by returning a tuple of

        (mode, value, opcode, restart_type)

        See Frame.unwind() for details on how this can return.
        """
        raise NotImplementedError()

    def get_line_and_column(self):
        return getattr(self.data, "line", None), getattr(self.data, "column", None)

    def return_value_jump(self, context, frame_manager, immediate_context=None):
        return evaluate(self, context, frame_manager, immediate_context)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression(
            "{return_value_jump}({context_name}, _frame_manager)",
            context_name, dependency_builder, return_value_jump=self.return_value_jump
        )


def evaluate(expression, context, frame_manager, immediate_context=None):
    if get_environment().return_value_optimization:
        # Optimized version that avoids creating a Capturer object, but only works for values
        try:
            mode, value, opcode, restart_type = expression.jump(context, frame_manager, immediate_context=immediate_context)
        except BreakException as b:
            if b.mode == "value":
                return b.value
            raise
        if mode == "value":
            return value
        raise BreakException(mode, value, opcode, restart_type)
    else:
        with frame_manager.capture("value") as result:
            result.attempt_capture_or_raise(*expression.jump(context, frame_manager, immediate_context=immediate_context))
        return result.value


def get_expression_break_types(expression, context, frame_manager, immediate_context=None, target_break_mode="value"):
    other_break_types = dict(expression.get_break_types(context, frame_manager, immediate_context))

    if get_environment().validate_flow_control:
        if not isinstance(other_break_types, dict):
            raise FatalError()
        for mode, break_types in other_break_types.items():
            if not isinstance(mode, basestring):
                raise FatalError()
            if not isinstance(break_types, (list, tuple)):
                raise FatalError()
            for break_type in break_types:
                if not isinstance(break_type, (dict, PythonDict)):
                    raise FatalError()
                if "out" not in break_type:
                    raise FatalError()
                if not isinstance(break_type["out"], Type):
                    raise FatalError()
                if "in" in break_type and not isinstance(break_type["in"], Type):
                    raise FatalError()

    target_break_types = other_break_types.pop(target_break_mode, MISSING)
    return target_break_types, other_break_types


def flatten_out_types(break_types):
    if get_environment().opcode_bindings:
        if not isinstance(break_types, list):
            raise FatalError()
        for b in break_types:
            if not isinstance(b, (dict, PythonDict)):
                raise FatalError()
            if "out" not in b:
                raise FatalError()

    return merge_types([b["out"] for b in break_types], "super")


class TypeErrorFactory(object):
    def __init__(self, message):
        self.message = message

    def __call__(self, message=None, **kwargs):
        data = {
            "type": "TypeError",
            "message": message or self.message,
            "kwargs": PythonDict(kwargs)
        }
        return PythonObject(data, bind=self.get_type(message), debug_reason="type-error")

    def get_type(self, message=None):
        properties = {
            "type": Const(UnitType("TypeError")),
            "message": Const(UnitType(message or self.message)),
            "kwargs": Const(UniversalDictType(StringType(), AnyType()))
        }
        return UniversalObjectType(properties, wildcard_type=AnyType(), name="TypeError")

def get_operand_type(expression, context, frame_manager, break_types, immediate_context=None):
    value_type, other_break_types = get_expression_break_types(
        expression, context, frame_manager, immediate_context=immediate_context
    )
    break_types.merge(other_break_types)
    if value_type is not MISSING:
        value_type = flatten_out_types(value_type)

    return value_type

def each_reference(reference_types, of_types):
    if reference_types is MISSING or of_types is MISSING:
        return

    for reference_type in unwrap_types(reference_types):
        try:
            possible_references = reference_type.get_all_permitted_values()
        except PermittedValuesDoesNotExist:
            possible_references = None

        for of_type in unwrap_types(of_types):
            if possible_references is None:
                yield [ MISSING, of_type ]
                continue
            for possible_reference in possible_references:
                yield [ possible_reference, of_type ]

def get_best_micro_op(tags, type):
    for tag in tags:
        micro_op = type.get_micro_op_type(tag)
        if micro_op:
            return ( tag, micro_op )

    return ( None, None )

class MicroOpBinder(object):
    def __init__(self):
        self.bound = {}

    def bind(self, key, tags, type):
        if not isinstance(type, CompositeType):
            return

        tag, micro_op = get_best_micro_op(tags, type)
        if micro_op:
            self.bound[key] = ( tag, micro_op )

        return micro_op

    def get(self, keys):
        for key in keys:
            if key in self.bound:
                return self.bound[key]

        return ( None, None ) 

    def simple_bind(self):
        if len(self.bound) == 1:
            return self.bound.values()[0]

        return (None, None)

class Nop(Opcode):
    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add("value", NoValueType())
        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(NO_VALUE)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression("NoValue", context_name, dependency_builder)


class LiteralOp(Opcode):
    def __init__(self, data, visitor):
        super(LiteralOp, self).__init__(data, visitor)
        self.value = data.value

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add("value", get_type_of_value(self.value))
        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(self.value)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if isinstance(self.value, int):
            return ast.Num(n=self.value)
        if isinstance(self.value, basestring):
            return ast.Str(s=self.value)
        raise FatalError()

    def __str__(self):
        return "LiteralOp<{}>".format(self.value)


class TemplateOp(Opcode):
    NO_VALUE_ASSIGNMENT = TypeErrorFactory("TemplateOp: no_value_assignment")

    def __init__(self, data, visitor):
        super(TemplateOp, self).__init__(data, visitor)
        if not isinstance(data.opcodes, PythonList):
            raise FatalError()
        for e in data.opcodes:
            if not isinstance(e, tuple) and len(e) != 2:
                raise FatalError()
        self.opcodes = [
            (enrich_opcode(key, visitor), enrich_opcode(opcode, visitor))
            for key, opcode in data.opcodes
        ]

    @abstractmethod
    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        micro_ops = {}

        all_key_types = []
        all_value_types = []

        can_break_with_value_type = True

        for key_opcode, value_opcode in self.opcodes:
            key_type, other_key_break_types = get_expression_break_types(key_opcode, context, frame_manager, immediate_context=immediate_context)
            break_types.merge(other_key_break_types)
            value_type, other_value_break_types = get_expression_break_types(value_opcode, context, frame_manager, immediate_context=immediate_context)
            break_types.merge(other_value_break_types)

            if key_type is MISSING:
                can_break_with_value_type = False
                continue

            key_type = flatten_out_types(key_type)
            key = None

            try:
                allowed_keys = key_type.get_all_permitted_values()
                if len(allowed_keys) == 1:
                    key = allowed_keys[0]
            except PermittedValuesDoesNotExist:
                pass

            if value_type is MISSING:
                can_break_with_value_type = False
                continue

            value_type = flatten_out_types(value_type)

            if isinstance(value_type, NoValueType):
                break_types.add("exception", self.NO_VALUE_ASSIGNMENT.get_type())
            else:
                all_value_types.extend(unwrap_types(value_type))
                all_key_types.extend(unwrap_types(key_type))
                micro_ops[("get", key)] = GetterMicroOpType(key, value_type)
                micro_ops[("set", key)] = SetterMicroOpType(key, AnyType())

        if can_break_with_value_type:
            combined_key_types = merge_types([ BottomType() ] + all_key_types, "exact")
            combined_value_types = merge_types([ BottomType() ] + all_value_types, "exact")
            have_default_factory = False

            micro_ops[("get-wildcard",)] = GetterWildcardMicroOpType(AnyType(), combined_value_types, True)
            micro_ops[("iter",)] = IterMicroOpType(combined_key_types, combined_value_types)
            micro_ops[("set-wildcard",)] = SetterWildcardMicroOpType(AnyType(), AnyType(), False, False)
            micro_ops[("delete-wildcard",)] = DeletterWildcardMicroOpType(AnyType(), not have_default_factory)
            micro_ops[("remove-wildcard",)] = RemoverWildcardMicroOpType(not have_default_factory, False)
            micro_ops[("insert-wildcard",)] = InserterWildcardMicroOpType(AnyType(), False, False)

            micro_ops[("insert-start",)] = InsertStartMicroOpType(AnyType(), False)
            micro_ops[("insert-end",)] = InsertEndMicroOpType(AnyType(), False)

            value_type = CompositeType(micro_ops, name="TemplateOp")

            break_types.add("value", value_type)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            result = {}

            initial_length = 0

            for index, (key_opcode, value_opcode) in enumerate(self.opcodes):
                key = frame.step("key-{}".format(index), lambda: evaluate(key_opcode, context, frame_manager))
                result[key] = frame.step("value-{}".format(index), lambda: evaluate(value_opcode, context, frame_manager))
                if result[key] is NO_VALUE:
                    frame.exception(self.NO_VALUE_ASSIGNMENT())

                if isinstance(key, int):
                    required_length_for_key = key + 1
                    initial_length = max([ required_length_for_key, initial_length ])

            return frame.value(
                Universal(
                    True,
                    initial_wrapped=result,
                    initial_length=initial_length,
                    debug_reason="object-template"
                )
            )

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        parameters = {}
        parameters.update({
            "key_ast{}".format(id(key)): key.to_ast(context_name, dependency_builder)
            for key, opcode in self.opcodes
        })
        parameters.update({
            "value_ast{}".format(id(opcode)): opcode.to_ast(context_name, dependency_builder)
            for key, opcode in self.opcodes
        })
        parameter_template = ",".join("{{key_ast{}}}: {{value_ast{}}}".format(id(key), id(opcode)) for key, opcode in self.opcodes)
        return compile_expression(
            "Universal(True, initial_wrapped={{ " + parameter_template + " }}, initial_length=CALCULATE_INITIAL_LENGTH)",
            context_name, dependency_builder, **parameters
        )
 
def get_context_type(context):
    if context is None:
        return NoValueType()
    context_manager = get_manager(context)
    if not hasattr(context_manager, "_context_type"):
        value_type = {}
        if context is NO_VALUE:
            return NoValueType()
        if hasattr(context, "_types"):
            if hasattr(context._types, "argument"):
                value_type["argument"] = context._types.argument
            if hasattr(context._types, "local"):
                value_type["local"] = context._types.local
            if hasattr(context._types, "outer"):
                value_type["outer"] = context._types.outer
        if hasattr(context, "prepare"):
            value_type["prepare"] = DEFAULT_READONLY_COMPOSITE_TYPE
        if hasattr(context, "static"):
            value_type["static"] = DEFAULT_READONLY_COMPOSITE_TYPE
        context_manager._context_type = UniversalObjectType(value_type, name="context-type-{}".format(context_manager.debug_reason))
 
    return context_manager._context_type


class ContextOp(Opcode):
    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add("value", get_context_type(context))
        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            return frame.value(context)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression(context_name, context_name, dependency_builder)

    def __str__(self):
        return "Context"

class DereferenceOp(Opcode):
    INVALID_DEREFERENCE = TypeErrorFactory("DereferenceOp: invalid_dereference")

    def __init__(self, data, visitor):
        super(DereferenceOp, self).__init__(data, visitor)
        self.of = enrich_opcode(data.of, visitor)
        self.reference = enrich_opcode(data.reference, visitor)
        self.safe = data.safe
        self.binder = MicroOpBinder()
        self.generates_exceptions = True

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        self.generates_exceptions = False

        reference_types = get_operand_type(self.reference, context, frame_manager, break_types)
        of_types = get_operand_type(self.of, context, frame_manager, break_types)

        if reference_types is MISSING or of_types is MISSING:
            return break_types.build()

        invalid_dereferences = set()
        invalid_unknown_dereference = False

        for reference, of_type in each_reference(reference_types, of_types):
            if reference is MISSING:
                # We don't know what the reference is at verification time - it might be
                # dynamic like an index into an array. Use wildcard microop and check for errors
                micro_op = self.binder.bind(None, [
                    ("get-wildcard", )
                ], of_type)                    
            else:
                # We know what the reference might be at verification time - attempt static
                # binding and fallback on wildcard microop, again checking for errors
                micro_op = self.binder.bind(reference, [
                    ("get", reference), ("get-wildcard", )
                ], of_type)

            if micro_op:
                break_types.add("value", micro_op.value_type)
            else:
                break_types.add("value", AnyType())

            if not micro_op or micro_op.type_error or micro_op.key_error:
                if reference is MISSING:
                    invalid_unknown_dereference = True
                else:
                    invalid_dereferences.add(reference)

        exception_break_mode = "exception" if self.safe else "value"
        for invalid_dereference in invalid_dereferences:
            break_types.add(exception_break_mode, self.INVALID_DEREFERENCE.get_type(
                message="DereferenceOp: invalid_dereference".format(invalid_dereference)
            ), opcode=self)
        if invalid_unknown_dereference:
            break_types.add(exception_break_mode, self.INVALID_DEREFERENCE.get_type(), opcode=self)

        self.generates_exceptions = len(invalid_dereferences) > 0 or invalid_unknown_dereference

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            of = frame.step("of", lambda: evaluate(self.of, context, frame_manager))
            reference = frame.step("reference", lambda: evaluate(self.reference, context, frame_manager))

            manager = get_manager(of)

            exception_break_mode = "exception" if self.safe else "value"

            if manager is None:
                return frame.unwind(exception_break_mode, self.INVALID_DEREFERENCE(reference=reference), None, None)

            try:
                tag, micro_op = self.binder.get(
                    [ reference, None ]
                )

                if micro_op is None:
                    # Runtime dynamic behaviour! We weren't even able to bind to the
                    # wildcard microop at verification time (maybe we dind't know whether
                    # the target would be a CompositeType). No harm though - we get the
                    # microop at runtime instead.
                    tag, micro_op = get_best_micro_op([
                        ( "get", reference ), ( "get-wildcard", )
                    ], manager.get_effective_composite_type())

                direct = tag and tag[0] != "get-wildcard"

                if not micro_op:                    
                    return frame.unwind(exception_break_mode, self.INVALID_DEREFERENCE(reference=reference), None, None)

                result = None

                if direct:
                    result = micro_op.invoke(manager, shortcut_checks=True)
                else:
                    result = micro_op.invoke(manager, reference, shortcut_checks=True)

                if result is SPARSE_ELEMENT:
                    return frame.unwind(exception_break_mode, self.INVALID_DEREFERENCE(reference=reference), None, None)

                return frame.value(result)
            except InvalidDereferenceType:
                return frame.unwind(exception_break_mode, self.INVALID_DEREFERENCE(
                    message="DereferenceOp: invalid_dereference"
                ), None, None)
            except InvalidDereferenceKey:
                return frame.unwind(exception_break_mode, self.INVALID_DEREFERENCE(
                    message="DereferenceOp: invalid_dereference"
                ), None, None)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        tag, micro_op_to_compile = self.binder.simple_bind()

        need_interpreted_version = (
            micro_op_to_compile is None
            or micro_op_to_compile.key_error
            or micro_op_to_compile.type_error
            or self.generates_exceptions
        )

        if need_interpreted_version:
            return super(DereferenceOp, self).to_ast(context_name, dependency_builder)

        direct = tag[0] == "set"

        if not direct:
            reference_ast = self.reference.to_ast(context_name, dependency_builder)
            args = (reference_ast,)
        else:
            args = ()

        return micro_op_to_compile.to_ast(
            dependency_builder,
            self.of.to_ast(context_name, dependency_builder),
            *args
        )

    def __str__(self):
        return "{}.{}".format(self.of, self.reference)


class DynamicDereferenceOp(Opcode):
    INVALID_DEREFERENCE = TypeErrorFactory("DynamicDereferenceOp: invalid_dereference {reference}")

    def __init__(self, data, visitor):
        super(DynamicDereferenceOp, self).__init__(data, visitor)
        self.reference = data.reference

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        break_types.add(
            "exception",
            self.INVALID_DEREFERENCE.get_type(message="DynamicDereferenceOp: invalid_dereference {}".format(self.reference)),
            opcode=self
        )

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        raise FatalError(self.reference)


class AssignmentOp(Opcode):
    INVALID_LVALUE = TypeErrorFactory("AssignmentOp: invalid_lvalue")
    INVALID_RVALUE = TypeErrorFactory("AssignmentOp: invalid_rvalue")
    INVALID_ASSIGNMENT = TypeErrorFactory("AssignmentOp: invalid_assignment")

    def __init__(self, data, visitor):
        super(AssignmentOp, self).__init__(data, visitor)
        self.of = enrich_opcode(data.of, visitor)
        self.reference = enrich_opcode(data.reference, visitor)
        self.rvalue = enrich_opcode(data.rvalue, visitor)
        self.binder = MicroOpBinder()
        self.generates_exceptions = True

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        self.generates_exceptions = False

        reference_types = get_operand_type(self.reference, context, frame_manager, break_types)
        of_types = get_operand_type(self.of, context, frame_manager, break_types)
        rvalue_type = get_operand_type(self.rvalue, context, frame_manager, break_types)

        if reference_types is MISSING or of_types is MISSING or rvalue_type is MISSING:
            # If any are missing, then this opcode can not execute
            return break_types.build()

        invalid_assignment_error = invalid_rvalue_error = invalid_lvalue_error = False

        break_types.add("value", NoValueType())

        for reference, of_type in each_reference(reference_types, of_types):
            if reference is MISSING:
                micro_op = self.binder.bind(None, [
                    ("set-wildcard", )
                ], of_type)                    
            else:
                micro_op = self.binder.bind(reference, [
                    ("set", reference), ("set-wildcard", )
                ], of_type)

            if micro_op:
                if not micro_op.value_type.is_copyable_from(rvalue_type, DUMMY_REASONER):
                    invalid_rvalue_error = True

                if micro_op.type_error or micro_op.key_error:
                    invalid_assignment_error = True
            else:
                invalid_lvalue_error = True

        if invalid_assignment_error:
            break_types.add("exception", self.INVALID_ASSIGNMENT.get_type(), opcode=self)
        if invalid_rvalue_error:
            break_types.add("exception", self.INVALID_RVALUE.get_type(), opcode=self)
        if invalid_lvalue_error:
            break_types.add("exception", self.INVALID_LVALUE.get_type(), opcode=self)

        self.generates_exceptions = invalid_assignment_error or invalid_rvalue_error or invalid_lvalue_error

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            of = frame.step("of", lambda: evaluate(self.of, context, frame_manager))
            reference = frame.step("reference", lambda: evaluate(self.reference, context, frame_manager))
            rvalue = frame.step("rvalue", lambda: evaluate(self.rvalue, context, frame_manager))

            manager = get_manager(of)

            try:
                tag, micro_op = self.binder.get([ reference, None ])
                direct = tag[0] != "set-wildcard"

                if not micro_op:
                    return frame.exception(self.INVALID_LVALUE())

                if not is_type_bindable_to_value(rvalue, micro_op.value_type):
                    return frame.exception(self.INVALID_RVALUE())

                if direct:
                    micro_op.invoke(manager, rvalue, shortcut_checks=True)
                else:
                    micro_op.invoke(manager, reference, rvalue, shortcut_checks=True)

                return frame.value(NO_VALUE)
            except InvalidAssignmentType:
                return frame.exception(self.INVALID_ASSIGNMENT())
            except InvalidAssignmentKey:
                return frame.exception(self.INVALID_ASSIGNMENT())

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        tag, micro_op_to_compile = self.binder.simple_bind()

        need_interpreted_version = (
            micro_op_to_compile is None
            or micro_op_to_compile.key_error
            or micro_op_to_compile.type_error
            or self.generates_exceptions
        )

        if need_interpreted_version:
            return super(AssignmentOp, self).to_ast(context_name, dependency_builder)

        rvalue_ast = self.rvalue.to_ast(context_name, dependency_builder)

        direct = tag[0] == "set"

        if not direct:
            reference_ast = self.reference.to_ast(context_name, dependency_builder)
            args = (reference_ast, rvalue_ast)
        else:
            args = (rvalue_ast,)

        return micro_op_to_compile.to_ast(
            dependency_builder,
            self.of.to_ast(context_name, dependency_builder),
            *args
        )

WILDCARD = InternalMarker("WILDCARD")

class InsertOp(Opcode):
    INVALID_LVALUE = TypeErrorFactory("InsertOp: invalid_lvalue")
    INVALID_RVALUE = TypeErrorFactory("InsertOp: invalid_rvalue")
    INVALID_ASSIGNMENT = TypeErrorFactory("InsertOp: invalid_assignment")

    def __init__(self, data, visitor):
        super(InsertOp, self).__init__(data, visitor)
        self.of = enrich_opcode(data.of, visitor)
        self.reference = enrich_opcode(data.reference, visitor)
        self.rvalue = enrich_opcode(data.rvalue, visitor)
        self.micro_ops = {}

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        reference_types, reference_break_types = get_expression_break_types(self.reference, context, frame_manager)
        break_types.merge(reference_break_types)
        if reference_types is not MISSING:
            reference_types = flatten_out_types(reference_types)

        of_types, of_break_types = get_expression_break_types(self.of, context, frame_manager)
        break_types.merge(of_break_types)
        if of_types is not MISSING:
            of_types = flatten_out_types(of_types)

        rvalue_type, rvalue_break_types = get_expression_break_types(self.rvalue, context, frame_manager)
        break_types.merge(rvalue_break_types)
        if rvalue_type is not MISSING:
            rvalue_type = flatten_out_types(rvalue_type)

        self.invalid_assignment_error = self.invalid_rvalue_error = self.invalid_lvalue_error = False

        if reference_types is MISSING or of_types is MISSING or rvalue_type is MISSING:
            return break_types.build()

        for reference_type in unwrap_types(reference_types):
            try:
                possible_references = reference_type.get_all_permitted_values()
            except PermittedValuesDoesNotExist:
                self.invalid_lvalue_error = True
                possible_references = [ WILDCARD ]

            for of_type in unwrap_types(of_types):
                for reference in possible_references:
                    micro_op = None

                    if isinstance(of_type, CompositeType) and reference == 0:
                        micro_op = of_type.get_micro_op_type(("insert-start",))
                        if micro_op:
                            self.micro_ops[reference] = True, micro_op

                    if not micro_op:
                        micro_op = of_type.get_micro_op_type(("insert-wildcard",))
                        if micro_op:
                            self.micro_ops[reference] = False, micro_op

                    if micro_op:
                        if not micro_op.value_type.is_copyable_from(rvalue_type, DUMMY_REASONER):
                            self.invalid_rvalue_error = True

                        break_types.add("value", NoValueType())

                        if micro_op.type_error or micro_op.key_error:
                            self.invalid_assignment_error = True
                    else:
                        self.invalid_lvalue_error = True

        if self.invalid_assignment_error:
            break_types.add("exception", self.INVALID_ASSIGNMENT.get_type())
        if self.invalid_rvalue_error:
            break_types.add("exception", self.INVALID_RVALUE.get_type())
        if self.invalid_lvalue_error:
            break_types.add("exception", self.INVALID_LVALUE.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            of = frame.step("of", lambda: evaluate(self.of, context, frame_manager))
            reference = frame.step("reference", lambda: evaluate(self.reference, context, frame_manager))
            rvalue = frame.step("rvalue", lambda: evaluate(self.rvalue, context, frame_manager))

            manager = get_manager(of)

            try:
                direct, micro_op = self.micro_ops.get(reference, self.micro_ops.get(WILDCARD, (None, None)))
                if self.invalid_lvalue_error and not micro_op:
                    return frame.exception(self.INVALID_LVALUE())

                if self.invalid_rvalue_error and not is_type_bindable_to_value(rvalue, micro_op.value_type):
                    return frame.exception(self.INVALID_RVALUE())

                if direct:
                    return frame.value(micro_op.invoke(manager, rvalue, shortcut_checks=True))
                else:
                    return frame.value(micro_op.invoke(manager, reference, rvalue, shortcut_checks=True))

                return frame.exception(self.INVALID_LVALUE())
            except InvalidAssignmentType:
                return frame.exception(self.INVALID_ASSIGNMENT())
            except InvalidAssignmentKey:
                return frame.exception(self.INVALID_ASSIGNMENT())


class MapOp(Opcode):
    MISSING_COMPOSITE_TYPE = TypeErrorFactory("{}: missing_composite_type")
    MISSING_ITER = TypeErrorFactory("{}: missing_iter")
    MISSING_MAPPER_FUNCTION = TypeErrorFactory("{}: missing_mapper_function")

    def __init__(self, data, visitor):
        super(MapOp, self).__init__(data, visitor)
        self.composite = enrich_opcode(data.composite, visitor)
        self.mapper = enrich_opcode(data.mapper, visitor)
        self.iter_micro_op = None

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        composite_type = get_operand_type(
            self.composite, context, frame_manager, break_types
        )

        if composite_type and isinstance(composite_type, CompositeType):
            self.iter_micro_op = composite_type.get_micro_op_type(("iter", ))

        if self.iter_micro_op:
            immediate_context = immediate_context or {}
            immediate_context["suggested_argument_type"] = UniversalTupleType([
                IntegerType(),
                self.iter_micro_op.key_type,
                self.iter_micro_op.value_type
            ])

        mapper_type = get_operand_type(
            self.mapper, context, frame_manager, break_types,
            immediate_context=immediate_context
        )

        if not isinstance(composite_type, CompositeType):
            break_types.add("exception", self.MISSING_COMPOSITE_TYPE.get_type(), opcode=self)
        if not self.iter_micro_op:
            break_types.add("exception", self.MISSING_ITER.get_type(), opcode=self)
        if not isinstance(mapper_type, ClosedFunctionType):
            break_types.add("exception", self.MISSING_MAPPER_FUNCTION.get_type(), opcode=self)

        # Be more liberal: mapper_type might be a OneOfType that includes ClosedFunctionType
        if self.iter_micro_op is not None and isinstance(mapper_type, ClosedFunctionType):
            mapper_break_types = dict(mapper_type.break_types)

            break_value_type = mapper_break_types.pop("break", MISSING)
            if break_value_type is not MISSING:
                break_types.add("value", break_value_type)

            mapper_continue_type = mapper_break_types.pop("continue", MISSING)
            if mapper_continue_type is not MISSING:
                mapper_continue_type = flatten_out_types(mapper_continue_type)

            ends = mapper_break_types.pop("end", MISSING) is not MISSING
            skips = mapper_break_types.pop("value", MISSING) is not MISSING

            break_types.merge(mapper_break_types)

            every_input_key_is_in_output = not ends and not skips

            micro_ops = {}

            keys = [ getattr(micro_op, "key", None) for micro_op in composite_type.get_micro_op_types().values() ]
            integer_keys = [ k for k in keys if isinstance(k, int) ]

            if every_input_key_is_in_output:
                for index in integer_keys:
                    micro_ops[("get", index)] = GetterMicroOpType(index, mapper_continue_type)
                    micro_ops[("set", index)] = GetterMicroOpType(index, AnyType())

            if mapper_continue_type is not MISSING:
                micro_ops[("get-wildcard",)] = GetterWildcardMicroOpType(IntegerType(), mapper_continue_type, True)
                micro_ops[("iter",)] = IterMicroOpType(IntegerType(), mapper_continue_type)

            micro_ops[("set-wildcard",)] = SetterWildcardMicroOpType(IntegerType(), AnyType(), True, False)
            micro_ops[("remove-wildcard",)] = RemoverWildcardMicroOpType(True, False)
            micro_ops[("insert-wildcard",)] = InserterWildcardMicroOpType(AnyType(), True, False)
            micro_ops[("insert-start",)] = InsertStartMicroOpType(AnyType(), False)
            micro_ops[("insert-end",)] = InsertEndMicroOpType(AnyType(), False)
            micro_ops[("delete-wildcard",)] = DeletterWildcardMicroOpType(IntegerType(), True)

            result = CompositeType(micro_ops, name="MapOp")
            break_types.add("value", result)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            composite = frame.step("composite", lambda: evaluate(self.composite, context, frame_manager))
            mapper = frame.step("mapper", lambda: evaluate(self.mapper, context, frame_manager))

            with frame_manager.capture("break") as breaker:
                results = frame.step("results", lambda: [])

                composite_manager = get_manager(composite)

                # TODO: Make restartable - can not yet be used in a continuation
                for i, k, v in self.iter_micro_op.invoke(composite_manager):
                    with frame_manager.capture("end") as ender:
                        with frame_manager.capture("continue") as capturer:
                            with frame_manager.capture("value"):
                                mapper.invoke(PythonList([ i, k, v ]), frame_manager)
                        if capturer.value is not MISSING:
                            results.append(capturer.value)
                    if ender.value is not MISSING:
                        break
                return frame.value(PythonList(results))
            if breaker.value is not MISSING:
                return frame.value(breaker.value)

            raise FatalError()

class LengthOp(Opcode):
    INVALID_COMPOSITE_TYPE = TypeErrorFactory("{}: invalid_composite_type")

    def __init__(self, data, visitor):
        super(LengthOp, self).__init__(data, visitor)
        self.composite = enrich_opcode(data.composite, visitor)

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        composite_type = get_operand_type(self.composite, context, frame_manager, break_types)

        if composite_type is not MISSING:
            break_types.add("value", IntegerType(), opcode=self)
        if not isinstance(composite_type, CompositeType):
            break_types.add("exception", self.INVALID_COMPOSITE_TYPE.get_type(), opcode=self)

        return break_types.build()

    @abstractmethod
    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            composite = frame.step("composite", lambda: evaluate(self.composite, context, frame_manager))

            if not isinstance(composite, Composite):
                frame.exception(self.INVALID_COMPOSITE_TYPE())

            return frame.value(composite._length)


def BinaryOp(name, symbol, func, argument_type, result_type, number_op=None, cmp_op=None):
    class _BinaryOp(Opcode):
        MISSING_OPERANDS = TypeErrorFactory("{}: missing_integers".format(name))

        def __init__(self, data, visitor):
            super(_BinaryOp, self).__init__(data, visitor)
            self.lvalue = enrich_opcode(self.data.lvalue, visitor)
            self.rvalue = enrich_opcode(self.data.rvalue, visitor)
            self.missing_operands_exception = True

        def get_break_types(self, context, frame_manager, immediate_context=None):
            break_types = BreakTypesFactory(self)

            lvalue_type, lvalue_break_types = get_expression_break_types(self.lvalue, context, frame_manager)
            if lvalue_type is not MISSING:
                lvalue_type = flatten_out_types(lvalue_type)
            break_types.merge(lvalue_break_types)

            rvalue_type, rvalue_break_types = get_expression_break_types(self.rvalue, context, frame_manager)
            if rvalue_type is not MISSING:
                rvalue_type = flatten_out_types(rvalue_type)
            break_types.merge(rvalue_break_types)

            if lvalue_type is not MISSING and rvalue_type is not MISSING:
                break_types.add("value", result_type)
            self.missing_operands_exception = False
            if not argument_type.is_copyable_from(lvalue_type, DUMMY_REASONER) or not argument_type.is_copyable_from(rvalue_type, DUMMY_REASONER):
                self.missing_operands_exception = True
                break_types.add("exception", self.MISSING_OPERANDS.get_type())

            return break_types.build()

        def jump(self, context, frame_manager, immediate_context=None):
            with frame_manager.get_next_frame(self) as frame:
                def get_lvalue():
                    lvalue = frame.step("lvalue", lambda: evaluate(self.lvalue, context, frame_manager))
                    if self.missing_operands_exception and not argument_type.is_copyable_from(get_type_of_value(lvalue), DUMMY_REASONER):
                        raise BreakException(*frame.exception(self.MISSING_OPERANDS()))
                    return lvalue
    
                def get_rvalue():
                    rvalue = frame.step("rvalue", lambda: evaluate(self.rvalue, context, frame_manager))
                    if self.missing_operands_exception and not argument_type.is_copyable_from(get_type_of_value(rvalue), DUMMY_REASONER):
                        raise BreakException(*frame.exception(self.MISSING_OPERANDS()))
                    return rvalue

#                print "{} {} {}".format(get_lvalue(), symbol, get_rvalue())

                return frame.value(func(get_lvalue, get_rvalue))

        def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
            if not self.missing_operands_exception:
                if number_op:
                    lvalue_ast = self.lvalue.to_ast(context_name, dependency_builder)
                    rvalue_ast = self.rvalue.to_ast(context_name, dependency_builder)
                    return ast.BinOp(left=lvalue_ast, right=rvalue_ast, op=number_op)
                elif cmp_op:
                    lvalue_ast = self.lvalue.to_ast(context_name, dependency_builder)
                    rvalue_ast = self.rvalue.to_ast(context_name, dependency_builder)
                    return ast.Compare(left=lvalue_ast, ops=[ cmp_op ], comparators=[ rvalue_ast ])

            return Opcode.to_ast(self, context_name, dependency_builder)

    return _BinaryOp


class TransformOp(Opcode):
    def __init__(self, data, visitor):
        super(TransformOp, self).__init__(data, visitor)
        if hasattr(self.data, "code"):
            self.expression = enrich_opcode(self.data.code, visitor)
            if not hasattr(self.data, "input"):
                raise PreparationException("input missing in transform opcode")
            self.input = self.data.input
        else:
            self.expression = None
            self.input = None

        if not hasattr(self.data, "output"):
            raise PreparationException("output missing in transform opcode")
        self.output = self.data.output

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        if self.expression:
            expression_break_types = dict(self.expression.get_break_types(context, frame_manager))
            if self.output not in expression_break_types:
                expression_break_types[self.output] = []
            if self.input in expression_break_types:
                expression_break_types[self.output].extend(expression_break_types.pop(self.input))
            break_types.merge(expression_break_types)
        else:
            break_types.add(self.output, NoValueType())

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            if self.expression:
                with frame_manager.capture(self.input) as capture_result:
                    capture_result.attempt_capture_or_raise(*self.expression.jump(context, frame_manager))

                return frame.unwind(self.output, capture_result.value, None, None)
            else:
                return frame.unwind(self.output, NO_VALUE, None, None)
        raise FatalError()

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if self.expression is None:
            return compile_statement("""
raise BreakException("{output}", NoValue, None, None)
                """, context_name, dependency_builder,
                output=self.output
            )

        expression_ast = self.expression.to_ast(
            context_name,
            dependency_builder,
            will_ignore_return_value=will_ignore_return_value and self.input != "value"
        )

        if self.input == "value":
            return compile_statement("""
raise BreakException("{output}", {expression}, None, None)
                """, context_name, dependency_builder,
                output=self.output, expression=expression_ast
            )
        elif self.output == "value":
            if will_ignore_return_value:
                return compile_statement("""
try:
    {expression}
except BreakException as b:
    if b.mode != "{input}":
        raise
                    """, context_name, dependency_builder,
                    input=self.input,
                    expression=expression_ast
                )
            else:
                try_catcher = compile_statement("""
def TransformOpTryCatcher{opcode_id}({context_name}, _frame_manager):
    try:
        {expression}
    except BreakException as b:
        if b.mode == "{input}":
            return b.value
        raise
                    """, context_name, dependency_builder,
                    opcode_id=dependency_builder.get_next_id(),
                    input=self.input,
                    expression=expression_ast
                )

                return compile_expression("""
{try_catcher}({context_name}, _frame_manager)
                    """, context_name, dependency_builder,
                    try_catcher=try_catcher
                )
        else:
            return super(TransformOp, self).to_ast(context_name)


class ShiftOp(Opcode):
    def __init__(self, data, visitor):
        super(ShiftOp, self).__init__(data, visitor)
        self.opcode = enrich_opcode(data.code, visitor)
        self.restart_type = enrich_opcode(data.restart_type, visitor)

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        value_type, other_break_types = get_expression_break_types(self.opcode, context, frame_manager, immediate_context) 

        restart_type_value = evaluate(self.restart_type, context, frame_manager)
        with scoped_bind(restart_type_value, DEFAULT_READONLY_COMPOSITE_TYPE):
            self.restart_type = enrich_type(restart_type_value)

        value_type = flatten_out_types(value_type)
        break_types.merge(other_break_types)

        break_types.add("yield", value_type, self.restart_type)
        break_types.add("value", self.restart_type)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            if frame.has_restart_value():
                restart_value = frame.pop_restart_value()

                if get_environment().validate_flow_control:
                    if not self.restart_type.is_copyable_from(get_type_of_value(restart_value), DUMMY_REASONER):
                        raise FatalError()

                return frame.unwind("value", restart_value, None, None)

            value = evaluate(self.opcode, context, frame_manager)

            return frame.yield_(value, self.restart_type)


class ResetOp(Opcode):
    MISSING_IN_BREAK_TYPE = TypeErrorFactory("ResetOp: missing_in_break_type")
    MISSING_FUNCTION = TypeErrorFactory("ResetOp: missing_function")

    def __init__(self, data, visitor):
        super(ResetOp, self).__init__(data, visitor)
        if hasattr(data, "code"):
            self.opcode = enrich_opcode(data.code, visitor)
            self.function = None
            self.argument = None
        else:
            self.opcode = None
            self.function = enrich_opcode(data.function, visitor)
            self.argument = enrich_opcode(data.argument, visitor)

    def get_value_and_continuation_block_type(self, out_break_type, in_break_type, continuation_break_types):
        return UniversalObjectType({
            "value": Const(out_break_type),
            "continuation": Const(ClosedFunctionType(in_break_type, continuation_break_types))
        }, name="ValueAndContinuation")

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        yield_break_types = []
        self.continuation_break_types = None

        if self.opcode:
            opcode_break_types = dict(self.opcode.get_break_types(context, frame_manager))
            self.continuation_break_types = dict(opcode_break_types)
            yield_break_types = opcode_break_types.pop("yield", [])
            break_types.merge(opcode_break_types)
        else:
            function_type, function_break_types = get_expression_break_types(self.function, context, frame_manager)
            if function_type is not MISSING:
                function_type = flatten_out_types(function_type)
            break_types.merge(function_break_types)

            if isinstance(function_type, ClosedFunctionType): 
                self.continuation_break_types = function_type.break_types
                function_break_types = dict(function_type.break_types)
                yield_break_types = function_break_types.pop("yield", [])
                break_types.merge(function_break_types)
            else:
                break_types.add("exception", self.MISSING_FUNCTION.get_type(), opcode=self)

        missing_in_error = False

        for yield_break_type in yield_break_types:
            if "in" not in yield_break_type:
                missing_in_error = True
            break_types.add(
                "yield",
                self.get_value_and_continuation_block_type(
                    yield_break_type["out"], yield_break_type["in"], self.continuation_break_types
                )
            )

        if missing_in_error:
            break_types.add("exception", self.MISSING_IN_BREAK_TYPE.get_type(), opcode=self)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        from lockdown.executor.function import Continuation

        with frame_manager.get_next_frame(self) as frame:
            if self.opcode:
                def enter_expression():
                    return self.opcode.jump(context, frame_manager)
                with frame_manager.capture("yield") as capture_result:
                    capture_result.attempt_capture_or_raise(*enter_expression())

                if capture_result.caught_frames is MISSING:
                    return frame.exception(self.MISSING_IN_BREAK_TYPE())

                restart_continuation = capture_result.create_continuation(
                    enter_expression, self.continuation_break_types
                )
            else:
                argument = frame.step("argument", lambda: evaluate(self.argument, context, frame_manager))
                function = frame.step("function", lambda: evaluate(self.function, context, frame_manager))

                def enter_function():
                    return function.invoke(argument, frame_manager)

                with frame_manager.capture("yield") as capture_result:
                    capture_result.attempt_capture_or_raise(*enter_function())

                if capture_result.caught_frames is MISSING:
                    return frame.exception(self.MISSING_IN_BREAK_TYPE())

                if isinstance(function, Continuation):
                    # Avoid using enter_function as the callback, hook into the original
                    # continuation callback, avoiding an infinite chain of linked callbacks.
                    restart_continuation = capture_result.create_continuation(
                        function.callback, self.continuation_break_types
                    )
                else:
                    restart_continuation = capture_result.create_continuation(
                        enter_function, self.continuation_break_types
                    )

            restart_continuation_type = restart_continuation.get_type()

            result = PythonObject({
                "value": capture_result.value,
                "continuation": restart_continuation
            }, bind=self.get_value_and_continuation_block_type(
                get_type_of_value(capture_result.value),
                restart_continuation_type.argument_type,
                restart_continuation_type.break_types
            ))

            return frame.yield_(result)


class CommaOp(Opcode):
    def __init__(self, data, visitor):
        super(CommaOp, self).__init__(data, visitor)
        self.opcodes = [ enrich_opcode(o, visitor) for o in data.opcodes ]

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        value_type = [{ "out": NoValueType() }]

        for opcode in self.opcodes:
            value_type, other_break_types = get_expression_break_types(opcode, context, frame_manager)
            break_types.merge(other_break_types)
            if value_type is MISSING:
                break

        if value_type is not MISSING:
            break_types.merge({ "value": value_type })

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        value = NO_VALUE
        with frame_manager.get_next_frame(self) as frame:
            for index, opcode in enumerate(self.opcodes):
                value = frame.step(index, lambda: evaluate(opcode, context, frame_manager))
                if value is None:
                    pass

            return frame.value(value)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        asts = [
            e.to_ast(context_name, dependency_builder, will_ignore_return_value if i == len(self.opcodes) - 1 else True)
            for i, e in enumerate(self.opcodes)
        ]
        if will_ignore_return_value:
            asts = unwrap_modules(asts)
            asts = [wrap_as_statement(a) for a in asts]
            return ast.Module(body=asts)
        else:
            asts = unwrap_modules(asts)
            asts[-1] = compile_statement(
                "return {ast}",
                context_name, dependency_builder, ast=asts[-1]
            )
            asts = [wrap_as_statement(a) for a in asts]
            ast_placeholders = [ ("ast_{}_{}".format(id(self), id(e_ast)), e_ast) for e_ast in asts ]
            comma_function = compile_statement(
                "def CommaOp{opcode_id}({context_name}, _frame_manager):\n\t{" + "}\n\t{".join([ k for (k, _) in ast_placeholders ]) + "}",
                context_name, dependency_builder, opcode_id=id(self), **dict(ast_placeholders)
            )
            return compile_expression(
                "{comma_function}({context_name}, _frame_manager)",
                context_name, dependency_builder, comma_function=comma_function
            )


class LoopOp(Opcode):
    def __init__(self, data, visitor):
        self.code = enrich_opcode(data.code, visitor)
        self.has_continues = True
        self.has_ends = True
        self.has_breaks = True # TODO remove - this can be achieved with a outer TransformOp

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        _, other_break_types = get_expression_break_types(self.code, context, frame_manager)
        continue_value_type = other_break_types.pop("continue", MISSING)
        end_break = other_break_types.pop("end", MISSING)
        mode_break_type = other_break_types.pop("break", MISSING)

        self.has_continues = continue_value_type is not MISSING
        self.has_ends = end_break is not MISSING
        self.has_breaks = mode_break_type is not MISSING

        if end_break is not MISSING:
            # The loop might end gracefully
            if continue_value_type is not MISSING:
                # The loop will generate continue values before ending
                continue_value_type = flatten_out_types(continue_value_type)
                break_types.add("value", UniversalListType(continue_value_type))
            else:
                # The loop will not generate continue values before ending
                break_types.add("value", UniversalTupleType([]))

        if mode_break_type is not MISSING:
            # The loop might break out suddenly with a value
            mode_break_type = flatten_out_types(mode_break_type)
            break_types.add("value", mode_break_type)

        break_types.merge(other_break_types)
        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        code = self.code
        results = []

        with frame_manager.get_next_frame(self) as frame:
            with frame_manager.capture("break") as breaker:
                while True:
                    with frame_manager.capture("end") as ender:
                        with frame_manager.capture("continue") as capturer:
                            evaluate(code, context, frame_manager)
                        if capturer.value is not MISSING:
                            results.append(capturer.value)
                    if ender.value is not MISSING:
                        return frame.value(PythonList(results))
            if breaker.value is not MISSING:
                return frame.value(breaker.value)

        raise FatalError()

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if not will_ignore_return_value:
            return super(LoopOp, self).to_ast(context_name, dependency_builder)
        else:
            return compile_statement("""
try:
    while True:
        try:
            {expression}
        except BreakException as e:
            if e.mode == "continue":
                pass
            raise
except BreakException as e:
    if e.mode not in ("end", "break"):
        raise
    """,
                context_name,
                dependency_builder,
                expression=self.code.to_ast(context_name, dependency_builder, will_ignore_return_value=True)
            )


class ConditionalOp(Opcode):
    INVALID_CONDITIONAL = TypeErrorFactory("ConditionalOp: invalid_conditional")

    def __init__(self, data, visitor):
        super(ConditionalOp, self).__init__(data, visitor)
        self.condition = enrich_opcode(data.condition, visitor)
        self.when_true = enrich_opcode(data.when_true, visitor)
        self.when_false = enrich_opcode(data.when_false, visitor)

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        condition_type, condition_break_types = get_expression_break_types(self.condition, context, frame_manager)
        when_true_type, when_true_break_types = get_expression_break_types(self.when_true, context, frame_manager)
        when_false_type, when_false_break_types = get_expression_break_types(self.when_false, context, frame_manager)

        # TODO throw away one branch if condition_type can't be true or false
        break_types.merge(condition_break_types)
        break_types.merge(when_true_break_types)
        break_types.merge(when_false_break_types)

        if condition_type is not MISSING:
            condition_type = flatten_out_types(condition_type)
            if condition_type.is_copyable_from(UnitType(True), DUMMY_REASONER):
                if when_true_type is not MISSING:
                    when_true_type = flatten_out_types(when_true_type)
                    break_types.add("value", when_true_type)
            if condition_type.is_copyable_from(UnitType(False), DUMMY_REASONER):
                if when_false_type is not MISSING:
                    when_false_type = flatten_out_types(when_false_type)
                    break_types.add("value", when_false_type)

            if not condition_type.is_copyable_from(UnitType(True), DUMMY_REASONER) and not condition_type.is_copyable_from(UnitType(False), DUMMY_REASONER):
                break_types.add("exception", self.INVALID_CONDITIONAL.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            condition = frame.step("condition", lambda: evaluate(self.condition, context, frame_manager))

            if condition is True:
                result = frame.step("true_result", lambda: evaluate(self.when_true, context, frame_manager))
            elif condition is False:
                result = frame.step("false_result", lambda: evaluate(self.when_false, context, frame_manager))
            else:
                frame.exception(self.INVALID_CONDITIONAL())

            return frame.value(result)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        if will_ignore_return_value:
            return compile_statement("""
if {condition}:
    {when_true}
else:
    {when_false}
                """, context_name, dependency_builder,
                condition=self.condition.to_ast(context_name, dependency_builder),
                when_true=self.when_true.to_ast(context_name, dependency_builder),
                when_false=self.when_false.to_ast(context_name, dependency_builder)
            )

        else:
            return compile_expression("""
{when_true} if {condition} else {when_false}
                """, context_name, dependency_builder,
                condition=self.condition.to_ast(context_name, dependency_builder),
                when_true=self.when_true.to_ast(context_name, dependency_builder),
                when_false=self.when_false.to_ast(context_name, dependency_builder)
            )


class PrepareOp(Opcode):
    PREPARATION_ERROR = TypeErrorFactory("Prepare: preparation_error")

    def __init__(self, data, visitor):
        super(PrepareOp, self).__init__(data, visitor)
        self.code = enrich_opcode(data.code, visitor)

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        function_value_type, other_break_types = get_expression_break_types(self.code, context, frame_manager, immediate_context)

        break_types.merge(other_break_types)

        if function_value_type is not MISSING:
            break_types.add(
                "value", AnyType() #OpenFunctionType(BottomType(), get_context_type(context), {})
            )

        break_types.add("exception", self.PREPARATION_ERROR.get_type(), opcode=self)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            function_data = evaluate(self.code, context, frame_manager)

            from lockdown.executor.function import prepare

            immediate_context = immediate_context or {}
            immediate_context["suggested_outer_type"] = get_context_type(context)

            try:
                function = prepare(function_data, context, frame_manager, immediate_context)
            except PreparationException as e:
                return frame.exception(self.PREPARATION_ERROR(exception=str(e)), opcode=self)

            return frame.value(function)


class CloseOp(Opcode):
    INVALID_FUNCTION = TypeErrorFactory("Close: invalid_function")
    INVALID_OUTER_CONTEXT = TypeErrorFactory("Close: invalid_outer_context")

    def __init__(self, data, visitor):
        super(CloseOp, self).__init__(data, visitor)
        self.function = enrich_opcode(data.function, visitor)
        self.outer_context = enrich_opcode(data.outer_context, visitor)

        self.outer_context_type_error = True

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        function_type, function_break_types = get_expression_break_types(self.function, context, frame_manager, immediate_context=immediate_context)
        if function_type is not MISSING:
            function_type = flatten_out_types(function_type)
        break_types.merge(function_break_types)

        outer_context_type, outer_context_break_types = get_expression_break_types(self.outer_context, context, frame_manager, immediate_context=immediate_context)
        outer_context_type = flatten_out_types(outer_context_type)
        break_types.merge(outer_context_break_types)

        if function_type is not MISSING and outer_context_type is not MISSING:
            if isinstance(function_type, OpenFunctionType):
                break_types.add("value", ClosedFunctionType(function_type.argument_type, function_type.break_types))
                if function_type.outer_type.is_copyable_from(outer_context_type, DUMMY_REASONER):
                    self.outer_context_type_error = False
            else:
                break_types.add("value", AnyType())

        if self.outer_context_type_error:
            break_types.add("exception", self.INVALID_OUTER_CONTEXT.get_type(), opcode=self)

        if not isinstance(function_type, OpenFunctionType):
            break_types.add("exception", self.INVALID_FUNCTION.get_type(), opcode=self)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            open_function = frame.step("function", lambda: evaluate(self.function, context, frame_manager, immediate_context))
            outer_context = frame.step("outer", lambda: evaluate(self.outer_context, context, frame_manager, immediate_context))

            from lockdown.executor.function import OpenFunction

            if not isinstance(open_function, OpenFunction):
                return frame.exception(self.INVALID_FUNCTION())

            if (get_environment().opcode_bindings or self.outer_context_type_error):
                reasoner = Reasoner()
                if not does_value_fit_through_type(outer_context, open_function.outer_type, reasoner):
                    print(reasoner)
                    return frame.exception(self.INVALID_OUTER_CONTEXT())

            return frame.value(open_function.close(outer_context))

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression("""
{open_function}.close({outer_context})
            """, context_name, dependency_builder,
            open_function=self.function.to_ast(context_name, dependency_builder),
            outer_context=self.outer_context.to_ast(context_name, dependency_builder)
        )


def create_readonly_static_type(value):
    """
    For the StaticOp, for a given static value, produces a Type that opcodes
    that refer to the value from StaticOp are able to run against.
    """
    if isinstance(value, Composite):
        # Only do ListTypes atm since that is what is needed for unit tests, but can be expanded...
        result = CompositeType({}, name="reasonable list type")
        if isinstance(value, Universal):
            types_of_values = [ create_readonly_static_type(v) for v in value._values() ]
            merged_types = merge_types(types_of_values, "exact")

            for key, type_of_value in zip(value._keys(), types_of_values):
                result.set_micro_op_type(("get", key), GetterMicroOpType(key, type_of_value))

            result.set_micro_op_type(("get-wildcard",), GetterWildcardMicroOpType(IntegerType(), merged_types, True))
            result.set_micro_op_type(("iter",), IterMicroOpType(IntegerType(), merged_types))
        return result
    else:
        return get_type_of_value(value)


class StaticOp(Opcode):
    def __init__(self, data, visitor):
        super(StaticOp, self).__init__(data, visitor)
        self.code = enrich_opcode(data.code, visitor)
        self.value = MISSING

    def lazy_initialize(self, context, frame_manager, immediate_context):
        if self.value is MISSING:
            self.value = evaluate(self.code, context, frame_manager, immediate_context)

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        self.lazy_initialize(context, frame_manager, immediate_context)
        break_types.add("value", create_readonly_static_type(self.value))
        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            self.lazy_initialize(context, frame_manager, immediate_context)
            return frame.unwind("value", self.value, None, None)

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        return compile_expression(
            "{static_value}",
            context_name,
            dependency_builder,
            static_value=self.value
        )


class InvokeOp(Opcode):
    INVALID_FUNCTION_TYPE = TypeErrorFactory("Invoke: invalid_function_type")
    INVALID_ARGUMENT_TYPE = TypeErrorFactory("Invoke: invalid_argument_type")

    def __init__(self, data, visitor):
        super(InvokeOp, self).__init__(data, visitor)
        self.function = enrich_opcode(data.function, visitor)
        self.argument = enrich_opcode(data.argument, visitor)
        self.invalid_argument_type_exception_is_possible = True

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)

        immediate_context = {}
        argument_type, other_argument_break_types = get_expression_break_types(self.argument, context, frame_manager)
        if argument_type is not MISSING:
            argument_type = flatten_out_types(argument_type)
            immediate_context["suggested_argument_type"] = argument_type
        break_types.merge(other_argument_break_types)

        function_type, other_function_break_types = get_expression_break_types(
            self.function, context, frame_manager, immediate_context=immediate_context
        )
        break_types.merge(other_function_break_types)

        if function_type is not MISSING and argument_type is not MISSING:
            function_type = flatten_out_types(function_type)

            if isinstance(function_type, ClosedFunctionType):
                break_types.merge(function_type.break_types)
                reasoner = Reasoner()
                if function_type.argument_type.is_copyable_from(argument_type, reasoner):
                    self.invalid_argument_type_exception_is_possible = False
            else:
                break_types.add("exception", self.INVALID_FUNCTION_TYPE.get_type(), opcode=self)
                break_types.add("*", AnyType(), opcode=self)

            if self.invalid_argument_type_exception_is_possible:
                break_types.add("exception", self.INVALID_ARGUMENT_TYPE.get_type(), opcode=self)

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        from lockdown.executor.function import LockdownFunction

        with frame_manager.get_next_frame(self) as frame:
            function = frame.step("function", lambda: evaluate(self.function, context, frame_manager))
            argument = frame.step("argument", lambda: evaluate(self.argument, context, frame_manager))

            if not isinstance(function, LockdownFunction):
                return frame.exception(self.INVALID_FUNCTION_TYPE(), self)
            if self.invalid_argument_type_exception_is_possible and not does_value_fit_through_type(argument, function.get_type().argument_type):
                return frame.exception(self.INVALID_ARGUMENT_TYPE(), self) 

            return function.invoke(argument, frame_manager)

        raise FatalError()

    def to_ast(self, context_name, dependency_builder, will_ignore_return_value=False):
        from lockdown.executor.function import OpenFunction
        if (isinstance(self.function, CloseOp)
            and isinstance(self.function.function, StaticOp)
            and isinstance(self.function.function.value, OpenFunction)
        ):
            open_function = self.function.function.value
            if will_ignore_return_value:
                # to_inline_ast can return None if it's not possible to inline the open function
                inline_ast = open_function.to_inline_ast(
                    dependency_builder,
                    self.function.outer_context.to_ast(context_name, dependency_builder),
                    self.argument.to_ast(context_name, dependency_builder)
                )
                if inline_ast:
                    return inline_ast

            return compile_expression(
                "{function}.invoke({argument}, {outer_context}, _frame_manager)[1]",
                context_name, dependency_builder,
                function=open_function,
                outer_context=self.function.outer_context.to_ast(context_name, dependency_builder),
                argument=self.argument.to_ast(context_name, dependency_builder)
            )
        return compile_expression(
            "{function}.invoke({argument}, _frame_manager)[1]",
            context_name, dependency_builder,
            function=self.function.to_ast(context_name, dependency_builder),
            argument=self.argument.to_ast(context_name, dependency_builder)
        )


class MatchOp(Opcode):
    NO_MATCH = TypeErrorFactory("Match: no_match")

    def __init__(self, data, visitor):
        super(MatchOp, self).__init__(data, visitor)
        self.value = enrich_opcode(data.value, visitor)
        self.matchers = [ enrich_opcode(m, visitor) for m in data.matchers ]

        if not get_environment().rtti:
            raise FatalError("RTTI is required for MatchOp")

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        value_type, value_break_types = get_expression_break_types(self.value, context, frame_manager)
        value_type = flatten_out_types(value_type)

        break_types.merge(value_break_types)

        for matcher in self.matchers:
            matcher_function_type, matcher_break_types = get_expression_break_types(
                matcher,
                context,
                frame_manager,
                immediate_context={ "suggested_argument_type": value_type }
            )
            matcher_function_type = flatten_out_types(matcher_function_type)

            break_types.merge(matcher_break_types)
            break_types.merge(matcher_function_type.break_types)

            if matcher_function_type.argument_type.is_copyable_from(value_type, DUMMY_REASONER):
                break

            value_type = remove_type(value_type, matcher_function_type.argument_type)
        else:
            break_types.add("exception", self.NO_MATCH.get_type())

        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            value = frame.step("value", lambda: evaluate(self.value, context, frame_manager))

            for index, matcher in enumerate(self.matchers):
                matcher_function = frame.step(index, lambda: evaluate(matcher, context, frame_manager))
                if is_type_bindable_to_value(value, matcher_function.get_type().argument_type):
                    return matcher_function.invoke(value, frame_manager)
            else:
                return frame.exception(self.NO_MATCH())

        raise FatalError()

class PrintOp(Opcode):
    def __init__(self, data, visitor):
        super(PrintOp, self).__init__(data, visitor)
        self.expression = enrich_opcode(data.expression, visitor)

    def get_break_types(self, context, frame_manager, immediate_context=None):
        break_types = BreakTypesFactory(self)
        break_types.add("value", NoValueType())
        return break_types.build()

    def jump(self, context, frame_manager, immediate_context=None):
        with frame_manager.get_next_frame(self) as frame:
            print evaluate(self.expression, context, frame_manager)
            return frame.value(NO_VALUE)

FLOW_CONTROL_OPCODES = {
    "nop": Nop,
    "transform": TransformOp,
    "shift": ShiftOp,
    "reset": ResetOp,
    "comma": CommaOp,
    "loop": LoopOp,
    "conditional": ConditionalOp,

}

MATH_AND_LOGIC_OPCODES = {
        "multiplication": BinaryOp(
        "Multiplication", "*",
        lambda lvalue, rvalue: lvalue() * rvalue(), IntegerType(), IntegerType(), number_op=ast.Mult()
    ),
    "division": BinaryOp(
        "Division", "/",
        lambda lvalue, rvalue: lvalue() / rvalue(), IntegerType(), IntegerType(), number_op=ast.Div()
    ),
    "addition": BinaryOp(
        "Addition", "+",
        lambda lvalue, rvalue: lvalue() + rvalue(), IntegerType(), IntegerType(), number_op=ast.Add()
    ),
    "subtraction": BinaryOp(
        "Subtraction", "-",
        lambda lvalue, rvalue: lvalue() - rvalue(), IntegerType(), IntegerType(), number_op=ast.Sub()
    ),
    "mod": BinaryOp("Modulus", "%", lambda lvalue, rvalue: lvalue() % rvalue(), IntegerType(), IntegerType()),
    "lt": BinaryOp(
        "LessThan", "<",
        lambda lvalue, rvalue: lvalue() < rvalue(), IntegerType(), BooleanType(), cmp_op=ast.Lt()
    ),
    "lte": BinaryOp(
        "LessThanOrEqual", "<=",
        lambda lvalue, rvalue: lvalue() <= rvalue(), IntegerType(), BooleanType(), cmp_op=ast.LtE()
    ),
    "gt": BinaryOp(
        "GreaterThan", ">",
        lambda lvalue, rvalue: lvalue() > rvalue(), IntegerType(), BooleanType(), cmp_op=ast.Gt()
    ),
    "gte": BinaryOp(
        "GreaterThanOrEqual", ">=",
        lambda lvalue, rvalue: lvalue() >= rvalue(), IntegerType(), BooleanType(), cmp_op=ast.GtE()
    ),
    "eq": BinaryOp(
        "Equality", "==",
        lambda lvalue, rvalue: lvalue() == rvalue(), IntegerType(), BooleanType(), cmp_op=ast.Eq()
    ),
    "neq": BinaryOp(
        "Inequality", "!=",
        lambda lvalue, rvalue: lvalue() != rvalue(), IntegerType(), BooleanType(), cmp_op=ast.NotEq()
    ),
    "or": BinaryOp("Or", "||", lambda lvalue, rvalue: lvalue() or rvalue(), BooleanType(), BooleanType()),
    "and": BinaryOp("And", "&&", lambda lvalue, rvalue: lvalue() and rvalue(), BooleanType(), BooleanType()),
}

DATA_OPCODES = {
    "dereference": DereferenceOp,
    "dynamic_dereference": DynamicDereferenceOp,
    "assignment": AssignmentOp,
    "literal": LiteralOp,
    "template": TemplateOp,
    "insert": InsertOp,
    "map": MapOp,
    "length": LengthOp,
    "context": ContextOp,
    "static": StaticOp,
    "match": MatchOp,
}

FUNCTION_OPCODES = {
    "prepare": PrepareOp,
    "close": CloseOp,
    "invoke": InvokeOp,
}

MISC_OPCODES = {
    "print": PrintOp
}

OPCODES = spread_dict(
    FLOW_CONTROL_OPCODES,
    MATH_AND_LOGIC_OPCODES,
    DATA_OPCODES,
    FUNCTION_OPCODES,
    MISC_OPCODES
)


def enrich_opcode(data, visitor):
    if visitor:
        data = visitor(data)

    opcode = getattr(data, "opcode", MISSING)
    if opcode is MISSING:
        raise PreparationException("No opcode found in {}".format(data))
    if opcode not in OPCODES:
        raise PreparationException("Unknown opcode {} in {}".format(opcode, data))

    return OPCODES[opcode](data, visitor)

